<!DOCTYPE html>
<html data-n-head-ssr data-n-head="">
  <head>
    <meta data-n-head="true" charset="utf-8"/><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"/><meta data-n-head="true" name="keywords" content="翻译,JavaScript,优化,缓存"/><meta data-n-head="true" name="description" content="Fetch 请求的本地缓存"/><title data-n-head="true">[译] Fetch 请求的本地缓存 | 文蔺的博客</title><link data-n-head="true" rel="favicon" href="/favicon.ico"/><link rel="stylesheet" href="/static/common.5ad111a3.css"><style data-vue-ssr-id="645210e9:0">#__layout,#__nuxt,.wrapper{width:100%;height:100%}.main{height:100%}.main>article,.main>div,.main>section{min-height:100%;margin-bottom:-81px}.main>article:after,.main>div:after,.main>section:after{display:block;content:"";height:81px}.main>article,.main>div,.main>section{border-bottom:0}.main>#footer{position:relative;z-index:1;border-top:0}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><div class="nuxt-progress" style="width:0%;height:2px;background-color:black;opacity:0;"></div><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a><span>文蔺的博客</span></div><ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i><span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i><span> 归档</span></a></li><li><a href="/tags" title="标签"><i class="iconfont icon-tags"></i><span> 标签</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i><span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i><span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i><span> 收藏</span></a></li></ul></div><ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a><!----><!----><a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a><a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav><div id="header"><div class="btn-bar"><i></i></div><h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1><a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div><div id="sidebar-mask" style="display:none;"></div><div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-08-27</div></div><h1 class="title">[译] Fetch 请求的本地缓存</h1><div class="entry-content"><blockquote><p style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
        原文作者: <a href="https://twitter.com/peterbe" target="_blank">Peter Bengtsson</a><br>
        原文地址: <a href="https://www.sitepoint.com/cache-fetched-ajax-requests/">https://www.sitepoint.com/cache-fetched-ajax-requests/</a><br>
        译文地址: <a href="http://www.wemlion.com/post/cache-fetched-ajax-requests">http://www.wemlion.com/post/cache-fetched-ajax-requests</a><br>
        本文由 <a href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。<br>
        著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote><p><strong>本文展示了如何使用实现 fetch 请求的本地缓存</strong>，遇到重复请求时，将会从 sessionStorage 中读取数据。这样做的好处是，无需为每个需要缓存的资源编写自定义代码。</p><p>如果你想在 JavaScript 盛会中露露脸，秀秀如何玩转 Promise、最前沿的 API 和 localStorage，那就接着往下看吧。</p><h2 id="fetch-api">Fetch API</h2><p>此时此刻，你对 <a href="https://www.sitepoint.com/introduction-to-the-fetch-api/" target="_blank">fetch</a> 可能已经很熟悉了。它是浏览器提供的用以替代旧版的<textarea width="0" height="0" class="codespan" style="display:none;">XMLHttpRequest</textarea>的原生 API。</p><div data-ratio="2.8" class="aspect-ratio" style="padding:17.857% 0;" data-v-1990c624><iframe src="/caniuse/embed.html?feat=fetch&amp;periods=future_1,current,past_1,past_2" width="100%" height="100%" scrolling="no" frameborder="0" allowfullscreen="allowfullscreen" data-v-1990c624></iframe></div><p>并非所有浏览器都完美支持 fetch，但你可以使用 <a href="https://github.com/github/fetch" target="_blank">GitHub 上的 fetch polyfill</a>（如果没事做，可以看看 <a href="https://fetch.spec.whatwg.org/" target="_blank">Fetch 标准</a>）。</p><h2 id="-">原始替代版本</h2><p>做个假设，我们准确了解需要下载的那个资源，并且只想下载一次。可以使用全局变量作为缓存，像下面这样：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20origin%20%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Enull%3C%2Fspan%3E%0Afetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Einformation%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20origin%20%3D%20information.origin%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20your%20client's%20IP%3C%2Fspan%3E%0A%20%20%7D)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E9%9C%80%E8%A6%81%E5%BB%B6%E6%97%B6%E4%BB%A5%E7%A1%AE%E4%BF%9D%20fetch%20%E5%AE%8C%E6%88%90%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20origin)%0A%7D%2C%20%3Cspan%20class%3D%22hljs-number%22%3E3000%3C%2Fspan%3E)&lt;/code&gt;</textarea><p><a href="http://codepen.io/SitePoint/pen/QEPEpB?editors=0010#0" target="_blank">On CodePen</a></p><p>上面使用了全局变量来保存缓存的数据。马上可以发现问题，一旦刷新页面或者跳转到其他页面，缓存的数据就消失了。</p><p>在剖析这个办法的短板之前，先将解决方案升级下。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;fetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Einfo%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20sessionStorage.setItem(%3Cspan%20class%3D%22hljs-string%22%3E'information'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-built_in%22%3EJSON%3C%2Fspan%3E.stringify(info))%0A%20%20%7D)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E9%9C%80%E8%A6%81%E5%BB%B6%E6%97%B6%E4%BB%A5%E7%A1%AE%E4%BF%9D%20fetch%20%E5%AE%8C%E6%88%90%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20info%20%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3EJSON%3C%2Fspan%3E.parse(sessionStorage.getItem(%3Cspan%20class%3D%22hljs-string%22%3E'information'%3C%2Fspan%3E))%0A%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20info.origin)%0A%7D%2C%20%3Cspan%20class%3D%22hljs-number%22%3E3000%3C%2Fspan%3E)&lt;/code&gt;</textarea><p><a href="http://codepen.io/SitePoint/pen/zBXBwg?editors=0010#0" target="_blank">On CodePen</a></p><p>第一个问题是，<textarea width="0" height="0" class="codespan" style="display:none;">fetch</textarea> 是基于 Promise 的，意味着我们无法准确知晓 fetch 何时完成，因此在 fetch 完成之前，我们不能依赖它的执行。</p><p>第二个问题是，该解决方案详细指定了 URL 和缓存的内容（本例中的 <textarea width="0" height="0" class="codespan" style="display:none;">information</textarea>）。我们需要一个基于 URL 的通用解决方案。</p><h2 id="-">第一次的简单实现</h2><p>在 <textarea width="0" height="0" class="codespan" style="display:none;">fetch</textarea>外面再包装一层，同样也返回 Promise。调用该方法时，我们并不关心结果是来源于网络还是本地缓存。</p><p>之前你可能是这样做的：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;fetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Eissues%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20info.origin)%0A%20%20%7D)&lt;/code&gt;</textarea><p><a href="http://codepen.io/SitePoint/pen/pbBbwQ?editors=0011" target="_blank">On CodePen</a></p><p>现在加上一层包装，重复的网络请求可以通过本地缓存进行优化。我们将这个包装过的方法简单称作 <textarea width="0" height="0" class="codespan" style="display:none;">cachedFetch</textarea>，代码如下：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;cachedFetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Einfo%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20info.origin)%0A%20%20%7D)&lt;/code&gt;</textarea><p>该方法首次运行的时候，需要发出网络请求，并将结果缓存下来。第二次请求时，则会直接从本地存储中取出数据。</p><p>首先试试简单地将 <textarea width="0" height="0" class="codespan" style="display:none;">fetch</textarea> 包装下：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20cachedFetch%20%3D%20%3Cspan%20class%3D%22hljs-function%22%3E(%3Cspan%20class%3D%22hljs-params%22%3Eurl%2C%20options%3C%2Fspan%3E)%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20fetch(url%2C%20options)%0A%7D&lt;/code&gt;</textarea><p><a href="http://codepen.io/SitePoint/pen/kXmXwm?editors=0010#0" target="_blank">On CodePen</a></p><p>这当然能工作，不过没什么用。接下来，来实现获取数据的<strong>存储</strong>。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20cachedFetch%20%3D%20%3Cspan%20class%3D%22hljs-function%22%3E(%3Cspan%20class%3D%22hljs-params%22%3Eurl%2C%20options%3C%2Fspan%3E)%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%B0%86%20URL%20%E4%BD%9C%E4%B8%BA%20sessionStorage%20%E7%9A%84%20key%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20cacheKey%20%3D%20url%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20fetch(url%2C%20options).then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Eresponse%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%BB%85%E5%9C%A8%E7%BB%93%E6%9E%9C%E4%B8%BA%20JSON%20%E6%88%96%E5%85%B6%E4%BB%96%E9%9D%9E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%9C%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20ct%20%3D%20response.headers.get(%3Cspan%20class%3D%22hljs-string%22%3E'Content-Type'%3C%2Fspan%3E)%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(ct%20%26amp%3B%26amp%3B%20(ct.match(%3Cspan%20class%3D%22hljs-regexp%22%3E%2Fapplication%5C%2Fjson%2Fi%3C%2Fspan%3E)%20%7C%7C%20ct.match(%3Cspan%20class%3D%22hljs-regexp%22%3E%2Ftext%5C%2F%2Fi%3C%2Fspan%3E)))%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%BD%93%E7%84%B6%EF%BC%8C%E9%99%A4%E4%BA%86%20.text()%EF%BC%8C%E4%B9%9F%E6%9C%89%20.json()%20%E6%96%B9%E6%B3%95%3C%2Fspan%3E%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%B8%8D%E8%BF%87%E7%BB%93%E6%9E%9C%E6%9C%80%E7%BB%88%E8%BF%98%E6%98%AF%E4%BC%9A%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%20sessionStorage%20%E4%B8%AD%3C%2Fspan%3E%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%85%8B%E9%9A%86%20response%EF%BC%8C%E5%9C%A8%E5%85%B6%E8%BF%94%E5%9B%9E%E6%97%B6%E5%B0%B1%E4%BC%9A%E8%A2%AB%E4%BD%BF%E7%94%A8%3C%2Fspan%3E%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%BF%99%E9%87%8C%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BF%9D%E6%8C%81%E9%9D%9E%E5%85%A5%E4%BE%B5%E6%80%A7%3C%2Fspan%3E%0A%20%20%20%20%20%20response.clone().text().then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Econtent%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%20%20%20%20sessionStorage.setItem(cacheKey%2C%20content)%0A%20%20%20%20%20%20%7D)%0A%20%20%20%20%7D%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20response%0A%20%20%7D)%0A%7D&lt;/code&gt;</textarea><p><a href="http://codepen.io/SitePoint/pen/yJAJok?editors=0012" target="_blank">On CodePen</a></p><p>上面发生了不少事。</p><p><textarea width="0" height="0" class="codespan" style="display:none;">fetch</textarea> 所返回的首个 Promise 实际上还是径直发出了 GET 请求。注意如果有 CORS（Cross-Origin Resource Sharing，跨域资源共享）的问题，<textarea width="0" height="0" class="codespan" style="display:none;">.text()</textarea>、<textarea width="0" height="0" class="codespan" style="display:none;">.json()</textarea> 、<textarea width="0" height="0" class="codespan" style="display:none;">.blob()</textarea> 这些方法不会工作。</p><p>最有意思的点在于，我们需要<em>克隆</em>首个 Promise 返回的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/clone" target="_blank">Response</a> 对象。如果不这样做，我们就介入过多，当该 Promise 的最终使用者调用如 <textarea width="0" height="0" class="codespan" style="display:none;">.json()</textarea> 这些方法时，会得到如下错误：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-built_in%22%3ETypeError%3C%2Fspan%3E%3A%20Body%20has%20already%20been%20consumed.&lt;/code&gt;</textarea><p>另外需要注意的一点是，需要注意响应类型：我们只存储状态码为 <textarea width="0" height="0" class="codespan" style="display:none;">200</textarea><em>且</em>内容类型为 <textarea width="0" height="0" class="codespan" style="display:none;">application/json</textarea> 或 <textarea width="0" height="0" class="codespan" style="display:none;">text/*</textarea>的响应。因为 <textarea width="0" height="0" class="codespan" style="display:none;">sessionStorage</textarea> 只能存储文本数据。</p><p>下面是使用示例：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;cachedFetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Einfo%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20info.origin)%0A%20%20%7D)%0A%0AcachedFetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fhtml'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.text())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Edocument%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Document%20has%20'%3C%2Fspan%3E%20%2B%20%3Cspan%20class%3D%22hljs-built_in%22%3Edocument%3C%2Fspan%3E.match(%3Cspan%20class%3D%22hljs-regexp%22%3E%2F%26lt%3Bp%26gt%3B%2F%3C%2Fspan%3E).length%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20paragraphs'%3C%2Fspan%3E)%0A%20%20%7D)%0A%0AcachedFetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fimage%2Fpng'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.blob())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Eimage%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Image%20is%20'%3C%2Fspan%3E%20%2B%20image.size%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20bytes'%3C%2Fspan%3E)%0A%20%20%7D)&lt;/code&gt;</textarea><p>让人喜欢的是，这个解决方案到目前为止可以正常工作，也不会干扰 JSON <em>与</em> HTML 请求。当数据为图片的时候，它也不会试图将其存在 <textarea width="0" height="0" class="codespan" style="display:none;">sessionStorage</textarea> 中。</p><h2 id="-">真实返回命中缓存的第二次实现</h2><p>我们的第一次实现，仅仅只关心响应结果的<strong>存储</strong>。当你第二次调用 <textarea width="0" height="0" class="codespan" style="display:none;">cachedFetch</textarea> 时，并未试着从 <textarea width="0" height="0" class="codespan" style="display:none;">sessionStorage</textarea> 中<em>检索</em>任何内容。我们要做的，首先是返回一个 Promise，它需要返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/Response" target="_blank">Response 对象</a>。</p><p>先看下最基本的实现：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20cachedFetch%20%3D%20%3Cspan%20class%3D%22hljs-function%22%3E(%3Cspan%20class%3D%22hljs-params%22%3Eurl%2C%20options%3C%2Fspan%3E)%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%B0%86%20URL%20%E4%BD%9C%E4%B8%BA%20sessionStorage%20%E7%9A%84%20key%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20cacheKey%20%3D%20url%0A%0A%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%91%BD%E4%B8%AD%E7%BC%93%E5%AD%98%E7%9A%84%E6%96%B0%E4%BB%A3%E7%A0%81%E5%BC%80%E5%A7%8B%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20cached%20%3D%20sessionStorage.getItem(cacheKey)%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(cached%20!%3D%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Enull%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20it%20was%20in%20sessionStorage!%20Yay!%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20response%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20Response(%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20Blob(%5Bcached%5D))%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EPromise%3C%2Fspan%3E.resolve(response)%0A%20%20%7D%0A%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%91%BD%E4%B8%AD%E7%BC%93%E5%AD%98%E7%9A%84%E6%96%B0%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9D%9F%3C%2Fspan%3E%0A%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20fetch(url%2C%20options).then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Eresponse%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%BB%85%E5%9C%A8%E7%BB%93%E6%9E%9C%E4%B8%BA%20JSON%20%E6%88%96%E5%85%B6%E4%BB%96%E9%9D%9E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%9C%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(response.status%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-number%22%3E200%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20ct%20%3D%20response.headers.get(%3Cspan%20class%3D%22hljs-string%22%3E'Content-Type'%3C%2Fspan%3E)%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(ct%20%26amp%3B%26amp%3B%20(ct.match(%3Cspan%20class%3D%22hljs-regexp%22%3E%2Fapplication%5C%2Fjson%2Fi%3C%2Fspan%3E)%20%7C%7C%20ct.match(%3Cspan%20class%3D%22hljs-regexp%22%3E%2Ftext%5C%2F%2Fi%3C%2Fspan%3E)))%20%7B%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%BD%93%E7%84%B6%EF%BC%8C%E9%99%A4%E4%BA%86%20.text()%EF%BC%8C%E4%B9%9F%E6%9C%89%20.json()%20%E6%96%B9%E6%B3%95%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%B8%8D%E8%BF%87%E7%BB%93%E6%9E%9C%E6%9C%80%E7%BB%88%E8%BF%98%E6%98%AF%E4%BC%9A%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%20sessionStorage%20%E4%B8%AD%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%85%8B%E9%9A%86%20response%EF%BC%8C%E5%9C%A8%E5%85%B6%E8%BF%94%E5%9B%9E%E6%97%B6%E5%B0%B1%E4%BC%9A%E8%A2%AB%E4%BD%BF%E7%94%A8%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%BF%99%E9%87%8C%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BF%9D%E6%8C%81%E9%9D%9E%E5%85%A5%E4%BE%B5%E6%80%A7%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20response.clone().text().then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Econtent%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20sessionStorage.setItem(cacheKey%2C%20content)%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20response%0A%20%20%7D)%0A%7D&lt;/code&gt;</textarea><p><a href="http://codepen.io/SitePoint/pen/qNwNPb?editors=0012" target="_blank">On CodePen</a></p><p>这已经可以工作了！</p><p>打开 <a href="http://codepen.io/SitePoint/pen/qNwNPb?editors=0012" target="_blank">CodePen</a> 查看上面代码的实际效果，记得开启浏览器开发者工具中的  Network tab。多点几次 “Run” 按钮（CodePen 的右上角），可以发现，只有图片被反复请求。</p><p>本解决方案的好处是避免了“意面式回调”（callback spaghetti）。<textarea width="0" height="0" class="codespan" style="display:none;">sessionStorage.getItem</textarea> 的调用是同步的（也就是阻塞的），所以在 Promise 或者回调中无需应对“它在本地存储中是否存在？”这种问题。只要有内容，就返回缓存结果。否则就按正常逻辑执行。</p><h2 id="-">考虑失效时间的第三次实现</h2><p>到目前为止我们一直在使用 <textarea width="0" height="0" class="codespan" style="display:none;">sessionStorage</textarea>，它有点像 <textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea>，除了在<strong>打开新页面</strong>时会被清除这一点。这意味着我们在使用一种“自然形式”，内容不会缓存很久。如果要使用 <textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea> 来缓存内容，那就算远程内容改变了，浏览器还是会“永远”卡在本地内容。这太糟糕了。</p><p>更好的解决办法是提供<em>用户</em>控制。（这里的用户指的是使用 <textarea width="0" height="0" class="codespan" style="display:none;">cachedFetch</textarea> 函数的 Web 开发者。）就像 Memcached 或 Redis 这些服务端存储一样，我们可以指定缓存的使用期。</p><p>例如在 Python (with Flask) 中：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-bash&quot;&gt;%26gt%3B%26gt%3B%26gt%3B%20from%20werkzeug.contrib.cache%20import%20MemcachedCache%0A%26gt%3B%26gt%3B%26gt%3B%20cache%20%3D%20MemcachedCache(%5B%3Cspan%20class%3D%22hljs-string%22%3E'127.0.0.1%3A11211'%3C%2Fspan%3E%5D)%0A%26gt%3B%26gt%3B%26gt%3B%20cache.set(%3Cspan%20class%3D%22hljs-string%22%3E'key'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-string%22%3E'value'%3C%2Fspan%3E%2C%2010)%0ATrue%0A%26gt%3B%26gt%3B%26gt%3B%20cache.get(%3Cspan%20class%3D%22hljs-string%22%3E'key'%3C%2Fspan%3E)%0A%3Cspan%20class%3D%22hljs-string%22%3E'value'%3C%2Fspan%3E%0A%26gt%3B%26gt%3B%26gt%3B%20%3Cspan%20class%3D%22hljs-comment%22%3E%23%20waiting%2010%20seconds%3C%2Fspan%3E%0A...%0A%26gt%3B%26gt%3B%26gt%3B%20cache.get(%3Cspan%20class%3D%22hljs-string%22%3E'key'%3C%2Fspan%3E)%0A%26gt%3B%26gt%3B%26gt%3B&lt;/code&gt;</textarea><p>对此，目前 <textarea width="0" height="0" class="codespan" style="display:none;">sessionStorage</textarea> 和 <textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea> 都没有内建的功能实现，所以需要自己手动来实现。通过对比存储与缓存命中时的时间戳，可以达成目的。</p><p>在此之前，先看看大概应该长什么样子：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%8C%E5%A6%82%205%20min%3C%2Fspan%3E%0AcachedFetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Einfo%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20info.origin)%0A%20%20%7D)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%BC%A0%E9%80%92%E4%BB%A5%E7%A7%92%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%95%B0%E5%80%BC%3C%2Fspan%3E%0AcachedFetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-number%22%3E2%3C%2Fspan%3E%20*%20%3Cspan%20class%3D%22hljs-number%22%3E60%3C%2Fspan%3E)%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%202%20min%3C%2Fspan%3E%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Einfo%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20info.origin)%0A%20%20%7D)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%92%8C%20%20fetch%20%E9%80%89%E9%A1%B9%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8D%E5%AD%97%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20init%20%3D%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Emode%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'same-origin'%3C%2Fspan%3E%2C%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Eseconds%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-number%22%3E3%3C%2Fspan%3E%20*%20%3Cspan%20class%3D%22hljs-number%22%3E60%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%203%20min%3C%2Fspan%3E%0A%7D%0AcachedFetch(%3Cspan%20class%3D%22hljs-string%22%3E'https%3A%2F%2Fhttpbin.org%2Fget'%3C%2Fspan%3E%2C%20init)%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Er%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20r.json())%0A%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Einfo%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E'Your%20origin%20is%20'%3C%2Fspan%3E%20%2B%20info.origin)%0A%20%20%7D)&lt;/code&gt;</textarea><p>最重要的来了，每次保存响应数据的时候，<em>也</em>需要记录<em>何时</em>存储的。现在我们也可以切换到 <textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea> 上了。代码会保证我们不会命中过期的缓存，在 <textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea> 中内容原本是持久化的。</p><p>下面是最终的解决方案：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20cachedFetch%20%3D%20%3Cspan%20class%3D%22hljs-function%22%3E(%3Cspan%20class%3D%22hljs-params%22%3Eurl%2C%20options%3C%2Fspan%3E)%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20expiry%20%3D%20%3Cspan%20class%3D%22hljs-number%22%3E5%3C%2Fspan%3E%20*%20%3Cspan%20class%3D%22hljs-number%22%3E60%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E9%BB%98%E8%AE%A4%205%20min%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Etypeof%3C%2Fspan%3E%20options%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'number'%3C%2Fspan%3E)%20%7B%0A%20%20%20%20expiry%20%3D%20options%0A%20%20%20%20options%20%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%20%20%7D%20%3Cspan%20class%3D%22hljs-keyword%22%3Eelse%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Etypeof%3C%2Fspan%3E%20options%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'object'%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%BD%86%E6%84%BF%E4%BD%A0%E5%88%AB%E8%AE%BE%E7%BD%AE%E4%B8%BA%200%3C%2Fspan%3E%0A%20%20%20%20expiry%20%3D%20options.seconds%20%7C%7C%20expiry%0A%20%20%7D%0A%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%B0%86%20URL%20%E4%BD%9C%E4%B8%BA%20localStorage%20%E7%9A%84%20key%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20cacheKey%20%3D%20url%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20cached%20%3D%20localStorage.getItem(cacheKey)%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20whenCached%20%3D%20localStorage.getItem(cacheKey%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%3Ats'%3C%2Fspan%3E)%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(cached%20!%3D%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Enull%3C%2Fspan%3E%20%26amp%3B%26amp%3B%20whenCached%20!%3D%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Enull%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%80%B6%EF%BC%81%20%E5%AE%83%E5%9C%A8%20localStorage%20%E4%B8%AD%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%B0%BD%E7%AE%A1%20'whenCached'%20%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%BD%86%E5%87%8F%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%9A%E5%B0%86%E5%85%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20age%20%3D%20(%3Cspan%20class%3D%22hljs-built_in%22%3EDate%3C%2Fspan%3E.now()%20-%20whenCached)%20%2F%20%3Cspan%20class%3D%22hljs-number%22%3E1000%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(age%20%26lt%3B%20expiry)%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20response%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20Response(%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20Blob(%5Bcached%5D))%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EPromise%3C%2Fspan%3E.resolve(response)%0A%20%20%20%20%7D%20%3Cspan%20class%3D%22hljs-keyword%22%3Eelse%3C%2Fspan%3E%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%B8%85%E9%99%A4%E6%97%A7%E5%80%BC%3C%2Fspan%3E%0A%20%20%20%20%20%20localStorage.removeItem(cacheKey)%0A%20%20%20%20%20%20localStorage.removeItem(cacheKey%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%3Ats'%3C%2Fspan%3E)%0A%20%20%20%20%7D%0A%20%20%7D%0A%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20fetch(url%2C%20options).then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Eresponse%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%BB%85%E5%9C%A8%E7%BB%93%E6%9E%9C%E4%B8%BA%20JSON%20%E6%88%96%E5%85%B6%E4%BB%96%E9%9D%9E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%9C%3C%2Fspan%3E%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(response.status%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-number%22%3E200%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20ct%20%3D%20response.headers.get(%3Cspan%20class%3D%22hljs-string%22%3E'Content-Type'%3C%2Fspan%3E)%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(ct%20%26amp%3B%26amp%3B%20(ct.match(%3Cspan%20class%3D%22hljs-regexp%22%3E%2Fapplication%5C%2Fjson%2Fi%3C%2Fspan%3E)%20%7C%7C%20ct.match(%3Cspan%20class%3D%22hljs-regexp%22%3E%2Ftext%5C%2F%2Fi%3C%2Fspan%3E)))%20%7B%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%BD%93%E7%84%B6%EF%BC%8C%E9%99%A4%E4%BA%86%20.text()%EF%BC%8C%E4%B9%9F%E6%9C%89%20.json()%20%E6%96%B9%E6%B3%95%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E4%B8%8D%E8%BF%87%E7%BB%93%E6%9E%9C%E6%9C%80%E7%BB%88%E8%BF%98%E6%98%AF%E4%BC%9A%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%20sessionStorage%20%E4%B8%AD%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%85%8B%E9%9A%86%20response%EF%BC%8C%E5%9C%A8%E5%85%B6%E8%BF%94%E5%9B%9E%E6%97%B6%E5%B0%B1%E4%BC%9A%E8%A2%AB%E4%BD%BF%E7%94%A8%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%BF%99%E9%87%8C%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BF%9D%E6%8C%81%E9%9D%9E%E5%85%A5%E4%BE%B5%E6%80%A7%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20response.clone().text().then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Econtent%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20localStorage.setItem(cacheKey%2C%20content)%0A%20%20%20%20%20%20%20%20%20%20localStorage.setItem(cacheKey%2B%3Cspan%20class%3D%22hljs-string%22%3E'%3Ats'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-built_in%22%3EDate%3C%2Fspan%3E.now())%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20response%0A%20%20%7D)%0A%7D&lt;/code&gt;</textarea><p><a href="http://codepen.io/SitePoint/pen/KrYrXA?editors=0012" target="_blank">On CodePen</a></p><h2 id="-">未来更好、更理想、更酷的实现</h2><p>我们在避免过度变动 Web API，最棒的是 <textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea> 可比依赖网络快得多了。看看这篇文章对 <textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea> 和 XHR 的比较： <a href="https://www.peterbe.com/plog/localforage-vs.-xhr" target="_blank">localForage vs. XHR</a>。它还衡量了其他内容，但得出基本结论，<textarea width="0" height="0" class="codespan" style="display:none;">localStorage</textarea> 确实很快，磁盘缓存热身（disk-cache warm-ups，？不知如何翻译，请读者赐教）也很少出现。</p><p>接下来，我们还能怎样改进方案呢？</p><h3 id="-">处理二进制响应</h3><p>我们的实现没有考虑缓存非文本的内容，如图片等等，但这并非不可能。需要一些更多的代码。特别的，我们可能想存储更多关于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank">Blob</a> 的信息。从根本上说，所有响应都是 Blob。对文本和 JSON 来说，它只是字符串数组，<textarea width="0" height="0" class="codespan" style="display:none;">type</textarea> 和 <textarea width="0" height="0" class="codespan" style="display:none;">size</textarea> 并不真正那么重要，因为从字符串本身就能识别出来。对二进制内容而言，需要将它们转换为 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank">ArrayBuffer</a>。</p><p>关注更多内容，请看 <a href="http://codepen.io/SitePoint/pen/XKQKZv?editors=1010#0" target="_blank">CodePen</a> 上支持图片的实现。</p><h3 id="-">使用哈希键值缓存</h3><p>另外一点潜在的优化点是对用作 key 的每个 URL 进行哈希处理，使其变得更小，以空间换取速度（trade space for speed）。在上面的例子中，我们使用了很多非常短小整洁的 URL（如 <textarea width="0" height="0" class="codespan" style="display:none;">https://httpbin.org/get</textarea>），但如果你使用了大量的带有很多查询字符串的长 URL，这样做就很有意义了。</p><p>办法之一是使用<a href="http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/" target="_blank">这个不错的算法</a>，以其安全快速而知名：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20hashstr%20%3D%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3Es%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20hash%20%3D%20%3Cspan%20class%3D%22hljs-number%22%3E0%3C%2Fspan%3E%3B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(s.length%20%3D%3D%20%3Cspan%20class%3D%22hljs-number%22%3E0%3C%2Fspan%3E)%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20hash%3B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Efor%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20i%20%3D%20%3Cspan%20class%3D%22hljs-number%22%3E0%3C%2Fspan%3E%3B%20i%20%26lt%3B%20s.length%3B%20i%2B%2B)%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20char%20%3D%20s.charCodeAt(i)%3B%0A%20%20%20%20hash%20%3D%20((hash%26lt%3B%26lt%3B%3Cspan%20class%3D%22hljs-number%22%3E5%3C%2Fspan%3E)-hash)%2Bchar%3B%0A%20%20%20%20hash%20%3D%20hash%20%26amp%3B%20hash%3B%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Convert%20to%2032bit%20integer%3C%2Fspan%3E%0A%20%20%7D%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20hash%3B%0A%7D&lt;/code&gt;</textarea><p>如果觉得这个不错，看下 <a href="http://codepen.io/SitePoint/pen/LkvkON?editors=0012" target="_blank">CodePen</a>。在控制台上可以看到类似 <textarea width="0" height="0" class="codespan" style="display:none;">557027443</textarea> 这样的 key 值。</p><h2 id="-">结语</h2><p>现在我们拥有了一个可以使用在 web app 中的工作方案了，我们使用 Web API，并且知晓响应结果会很好地为用户缓存下来。</p><p>最后一件事大概是这个扩展置于本文之外，将其作为一个真实、具体的项目，加上测试和 <textarea width="0" height="0" class="codespan" style="display:none;">README</textarea>，并发布到 npm 上 —— 换个时间再做吧！</p></div></article><nav class="pagination"><a href="/post/better-keyboard-navigation-with-progressive-enhancement" title="[译] 渐进增强的键盘导航" class="prev">« [译] 渐进增强的键盘导航</a><a href="/post/offline-storage-for-progressive-web-apps" title="[译] 渐进式 Web App 的离线存储" class="next">[译] 渐进式 Web App 的离线存储 »</a></nav><div></div></div><footer id="footer" class="inner">
      © 2018 -  文蔺的博客
      <span> - </span><a href="/" class="nuxt-link-active">www.wemlion.com</a><br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> &amp; <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script type="text/javascript">window.__NUXT__={"layout":"default","data":[{}],"error":null,"serverRendered":true};</script><script src="/static/manifest.4f625a5f.js" defer></script><script src="/static/0-cf2867bf.js" defer></script><script src="/static/78-3db2461a.js" defer></script><script src="/static/common.d774ec7b.js" defer></script><script src="/static/app.ff62209b.js" defer></script>
  </body>
</html>

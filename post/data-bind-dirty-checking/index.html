<!DOCTYPE html>
<html data-n-head-ssr data-n-head="">
  <head>
    <meta data-n-head="true" charset="utf-8"/><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"/><meta data-n-head="true" name="keywords" content="翻译,ES6,数据绑定"/><meta data-n-head="true" name="description" content="手把手教你写一个 Javascript 框架：数据绑定"/><title data-n-head="true">[译] 手把手教你写一个 Javascript 框架：数据绑定 | 文蔺的博客</title><link data-n-head="true" rel="favicon" href="/favicon.ico"/><link rel="stylesheet" href="/static/common.5ad111a3.css"><style data-vue-ssr-id="645210e9:0">#__layout,#__nuxt,.wrapper{width:100%;height:100%}.main{height:100%}.main>article,.main>div,.main>section{min-height:100%;margin-bottom:-81px}.main>article:after,.main>div:after,.main>section:after{display:block;content:"";height:81px}.main>article,.main>div,.main>section{border-bottom:0}.main>#footer{position:relative;z-index:1;border-top:0}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><div class="nuxt-progress" style="width:0%;height:2px;background-color:black;opacity:0;"></div><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a><span>文蔺的博客</span></div><ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i><span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i><span> 归档</span></a></li><li><a href="/tags" title="标签"><i class="iconfont icon-tags"></i><span> 标签</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i><span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i><span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i><span> 收藏</span></a></li></ul></div><ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a><!----><!----><a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a><a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav><div id="header"><div class="btn-bar"><i></i></div><h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1><a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div><div id="sidebar-mask" style="display:none;"></div><div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-11-14</div></div><h1 class="title">[译] 手把手教你写一个 Javascript 框架：数据绑定</h1><div class="entry-content"><blockquote><p style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
        原文作者: <a href="https://blog.risingstack.com/author/bertalan/" target="_blank">Bertalan Miklos</a><br>
        原文地址: <a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/">https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/</a><br>
        译文地址: <a href="http://www.wemlion.com/post/data-bind-dirty-checking">http://www.wemlion.com/post/data-bind-dirty-checking</a><br>
        本文由 <a href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。<br>
        著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote><p><strong>本文是“编写 JavaScript 框架”系列的第四章。本章我将解释脏检查和基于getter/setter 访问器的数据绑定技术，并指出它们各自的优缺点。</strong></p><p>本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目<a href="http://nx-framework.com/" target="_blank">主页</a>查看。</p><p>本系列章节如下：</p><ul><li><a href="/2016/nx-project-structure/">项目结构（Project structuring）</a></li><li><a href="/2016/execution-timing/">执行调度（Execution timing）</a></li><li><a href="/2016/sandbox-code-evaluation/">沙箱求值（Sandboxed code evaluation）</a></li><li>数据绑定简介(本文)</li><li><a href="/2016/es6-proxy-data-binding/">ES6 Proxy 实现数据绑定</a></li><li>自定义元素</li><li>客户端路由</li></ul><h2 id="-">数据绑定简介</h2><blockquote><p>数据绑定是将数据源与数据提供者、消费者绑定并在它们之间保持同步的一种基本技术。</p></blockquote><p>上面这个基本定义指出了数据绑定技术的通用构建模块。</p><ul><li>定义数据提供者、消费者</li><li>定义哪些变化触发数据同步</li><li>数据提供者监听变化的方式</li><li>发送变化时运行的同步函数 —— 下文会将该函数称作 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea></li></ul><p>不同数据绑定技术采用不同方式实现以上几步。接下来几个小节介绍其中两种技术，即脏检查、getter/setter 访问器方法。介绍完它们后我将简要讨论它们各自的优缺点。</p><h3 id="-">脏检查</h3><p>脏检查可能是最广为人知的数据绑定方法。它是一种不错的传统选择，因其概念简单，无需复杂的语言特性支持。</p><h3 id="-">脏检查语法</h3><p>定义数据提供者和消费者无需任何特殊语法，仅靠普通 JavaScript 对象即可。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20provider%20%3D%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Emessage%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'Hello%20World'%3C%2Fspan%3E%0A%7D%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20consumer%20%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3Edocument%3C%2Fspan%3E.createElement(%3Cspan%20class%3D%22hljs-string%22%3E'p'%3C%2Fspan%3E)&lt;/code&gt;</textarea><p>数据同步通常由提供者属性变化触发。那些需要对变化进行观察的属性，必须明确映射到各自的<textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea>函数。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;observe(provider%2C%20%3Cspan%20class%3D%22hljs-string%22%3E'message'%3C%2Fspan%3E%2C%20message%20%3D%26gt%3B%20%7B%0A%20%20consumer.innerHTML%20%3D%20message%0A%7D)&lt;/code&gt;</textarea><p><textarea width="0" height="0" class="codespan" style="display:none;">observe()</textarea> 函数仅仅保存了 <textarea width="0" height="0" class="codespan" style="display:none;">(provider, property) -&gt; handler</textarea> 映射，留作后用。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobserve%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%2C%20prop%2C%20handler%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20provider._handlers%5Bprop%5D%20%3D%20handler%0A%7D&lt;/code&gt;</textarea><p>这样一来就可以定义数据提供者、消费者，为属性变化注册<textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea>函数。公有 API 部分已经完成，下面要完成的是内部实现。</p><h3 id="-">监听变化</h3><p>脏检查之所以“脏”是有原因的。它依赖周期性检查，而非直接监听属性变化。这种周期性检查通常称作 digest cycle。在一个 digest cycle 内，遍历由<textarea width="0" height="0" class="codespan" style="display:none;">observe()</textarea>所添加的每一个 <textarea width="0" height="0" class="codespan" style="display:none;">(provider, property) -&gt; handler</textarea> 入口，并检查属性自上一次遍历以来是否发生了变化。若发生变化，则运行<textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea>函数。简单实现如下：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Edigest%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3E%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20providers.forEach(digestProvider)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EdigestProvider%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Efor%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20prop%20%3Cspan%20class%3D%22hljs-keyword%22%3Ein%3C%2Fspan%3E%20provider._handlers)%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(provider._prevValues%5Bprop%5D%20!%3D%3D%20provider%5Bprop%5D)%20%7B%0A%20%20%20%20%20%20provider._prevValues%5Bprop%5D%20%3D%20provider%5Bprop%5D%0A%20%20%20%20%20%20handler(provider%5Bprop%5D)%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&lt;/code&gt;</textarea><p><textarea width="0" height="0" class="codespan" style="display:none;">digest()</textarea> 函数需要不时运行，以保障状态同步。</p><h2 id="getter-setter-">getter/setter 访问器方法</h2><p>getter/setter 访问器方法是当前的主流趋势，其支持广泛程度稍低，因为需要用到 ES5 getter/setter 功能。但这种方法之优雅足以弥补这个问题。</p><h3 id="-">访问器语法</h3><p>定义数据提供者需要一些特殊语法。普通提供者对象需要传给<textarea width="0" height="0" class="codespan" style="display:none;">observable()</textarea>函数，转换为可观察对象。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20provider%20%3D%20observable(%7B%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Egreeting%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'Hello'%3C%2Fspan%3E%2C%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Esubject%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'World'%3C%2Fspan%3E%0A%7D)%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20consumer%20%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3Edocument%3C%2Fspan%3E.createElement(%3Cspan%20class%3D%22hljs-string%22%3E'p'%3C%2Fspan%3E)&lt;/code&gt;</textarea><p>这完全可以弥补简单的 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea> 映射语法。在脏检查中，我们必须像下面这样，为每一个观察属性明确进行定义：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;observe(provider%2C%20%3Cspan%20class%3D%22hljs-string%22%3E'greeting'%3C%2Fspan%3E%2C%20greeting%20%3D%26gt%3B%20%7B%0A%20%20consumer.innerHTML%20%3D%20greeting%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20'%3C%2Fspan%3E%20%2B%20provider.subject%0A%7D)%0A%0Aobserve(provider%2C%20%3Cspan%20class%3D%22hljs-string%22%3E'subject'%3C%2Fspan%3E%2C%20subject%20%3D%26gt%3B%20%7B%0A%20%20consumer.innerHTML%20%3D%20provider.greeting%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20'%3C%2Fspan%3E%20%2B%20subject%0A%7D)&lt;/code&gt;</textarea><p>又笨又长。访问器技术可以在 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea> 函数中自动检测用到的提供者属性，这样就可以简化以上代码。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;observe(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20consumer.innerHTML%20%3D%20provider.greeting%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20'%3C%2Fspan%3E%20%2B%20provider.subject%0A%7D)&lt;/code&gt;</textarea><p><textarea width="0" height="0" class="codespan" style="display:none;">observe()</textarea> 的实现与脏检查并不相同。我们仅仅需要执行传入的 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea>，并在其执行期间将其标记为当前活动函数。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20activeHandler%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobserve%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Ehandler%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20activeHandler%20%3D%20handler%0A%20%20handler()%0A%20%20activeHandler%20%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%7D&lt;/code&gt;</textarea><p>我们利用 JavaScript 单线程特点，采用单一的<textarea width="0" height="0" class="codespan" style="display:none;">activehandler</textarea>变量来记录当前运行的<textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea> 函数。</p><h3 id="-">监听变化</h3><p>“访问器技术”终于闪亮登场。借助于 getter/setter 访问器在背后的强力支持，数据提供者 provider 的能力大大增强。基本的思想是，拦截 provider 的属性获取、设置操作。</p><ul><li><p>get：如果存在正在运行的<textarea width="0" height="0" class="codespan" style="display:none;">activeHandler</textarea>，则保存<textarea width="0" height="0" class="codespan" style="display:none;">(provider, property) -&gt; activeHandler</textarea>映射，稍后使用。</p></li><li><p>set：运行所有 <textarea width="0" height="0" class="codespan" style="display:none;">(provide, property)</textarea> 对应的 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea>函数。</p></li></ul><p><img alt="The accessor data binding technique."></p><p>下面是监听单个属性变化的简单实现：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EobservableProp%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%2C%20prop%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20value%20%3D%20provider%5Bprop%5D%0A%20%20%3Cspan%20class%3D%22hljs-built_in%22%3EObject%3C%2Fspan%3E.defineProperty(provider%2C%20prop%2C%20%7B%0A%20%20%20%20get%20()%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(activeHandler)%20%7B%0A%20%20%20%20%20%20%20%20provider._handlers%5Bprop%5D%20%3D%20activeHandler%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20value%0A%20%20%20%20%7D%2C%0A%20%20%20%20set%20(newValue)%20%7B%0A%20%20%20%20%20%20value%20%3D%20newValue%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20handler%20%3D%20obj._handlers%5Bprop%5D%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(handler)%20%7B%0A%20%20%20%20%20%20%20%20activeHandler%20%3D%20handler%0A%20%20%20%20%20%20%20%20handler()%0A%20%20%20%20%20%20%20%20activeHandler%20%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D)%0A%7D&lt;/code&gt;</textarea><p>上一节提到的<textarea width="0" height="0" class="codespan" style="display:none;">observable()</textarea>函数会递归遍历 provider 的属性，并使用 <textarea width="0" height="0" class="codespan" style="display:none;">observableProp()</textarea> 函数将它们统统转换为可观察对象。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobservable%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Efor%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20prop%20%3Cspan%20class%3D%22hljs-keyword%22%3Ein%3C%2Fspan%3E%20provider)%20%7B%0A%20%20%20%20observableProp(provider%2C%20prop)%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Etypeof%3C%2Fspan%3E%20provider%5Bprop%5D%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'object'%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%20%20observable(provider%5Bprop%5D)%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&lt;/code&gt;</textarea><p>这只是一个简单实现，但用来对比两种技术已足够。</p><h2 id="-">两种技术对比</h2><p>本节将简要指出脏检查和访问器两种技术各自的优缺点。</p><h3 id="-">语法形式</h3><p>脏检查无需定义提供者、消费者，但将 <textarea width="0" height="0" class="codespan" style="display:none;">(provider, property)</textarea> 和 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea> 进行映射的方式笨拙又不灵活。</p><p>访问器技术需要使用 <textarea width="0" height="0" class="codespan" style="display:none;">observable()</textarea> 函数对提供者进行封装，不过自动进行 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea> 映射弥补了不足。对于使用数据绑定的大型项目来说，访问器技术是必备特性。</p><h3 id="-">性能</h3><p>脏检查早就因其性能表现臭名昭著。每次 digest cycle 中，需要对每个 <textarea width="0" height="0" class="codespan" style="display:none;">(provider, property) -&gt; handler</textarea> 入口进行数次检查。此外，即便应用处于闲置状态也必须保持运转，因为它并不值得属性何时发生变化。</p><p>访问器方法更快一些，但在一些大型可观察对象面前，性能也可能发生退化。使用访问器替换提供者的所有属性，通常是过重了。一种解决办法是在必要时动态建立 getter/setter，而不是一次性提前完成。此外，还有一种简单方法是使用一个 <textarea width="0" height="0" class="codespan" style="display:none;">noObserve()</textarea> 函数包装不需要的属性，告诉 <textarea width="0" height="0" class="codespan" style="display:none;">observable()</textarea> 不要理会这些。但这会引入额外的语法。</p><h3 id="-">灵活性</h3><p>脏检查天生就能和扩展属性（动态添加的）以及访问器属性一起工作。</p><p>访问器技术在这方面有个弱点。初始化 getter/setter 时，扩展属性并不包含在内。比如对数组来说，这就会导致问题，但也能通过手动调用 <textarea width="0" height="0" class="codespan" style="display:none;">observableProp()</textarea> 来解决。访问器属性也无法支持，因为访问器属性无法再包装一次。一种常见的解决办法是使用 <textarea width="0" height="0" class="codespan" style="display:none;">computed()</textarea> 函数替代 getter。不过这会引入更多自定义语法。</p><h3 id="-">时间控制</h3><p>脏检查给我们的自由并不多，因为我们无从得知属性实际发生变化的时机。<textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea> 函数只能通过不时运行 <textarea width="0" height="0" class="codespan" style="display:none;">digest()</textarea> 循环而异步执行。</p><p>使用访问器技术，getter/setter 是同步触发的，因此就有了选择上的自由。我们可以决定是否立即执行 <textarea width="0" height="0" class="codespan" style="display:none;">handler()</textarea>，或者分批异步执行。前者保证了可预见性，后者则可以通过去重提升性能。</p><h2 id="-">关于下一章</h2><p>下一章我将介绍 <a href="https://github.com/RisingStack/nx-observe" target="_blank">nx-observe</a> 数据绑定工具，阐述如何用 ES6 Proxy 替代  ES5 getters/setters，以弥补访问器技术的多数不足之处。</p><h2 id="-">写在最后</h2><p>如果对 NX 框架感兴趣，请访问 <a href="http://nx-framework.com/" target="_blank">主页</a>。胆大的读者还可以在Github 上查看 <a href="https://github.com/RisingStack/nx-framework" target="_blank">NX 源码</a> 和 <a href="https://github.com/RisingStack/nx-observe" target="_blank">nx-observe 源码</a>。</p><p>希望你喜欢这篇文章。下一章我们将讨论 <a href="https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/" target="_blank">沙箱求值（Sandboxed code evaluation）</a>。</p></div></article><nav class="pagination"><a href="/post/execution-timing" title="[译] 手把手教你写一个 Javascript 框架：执行调度" class="prev">« [译] 手把手教你写一个 Javascript 框架：执行调度</a><a href="/post/es6-proxy-data-binding" title="[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定" class="next">[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定 »</a></nav><div></div></div><footer id="footer" class="inner">
      © 2018 -  文蔺的博客
      <span> - </span><a href="/" class="nuxt-link-active">www.wemlion.com</a><br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> &amp; <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script type="text/javascript">window.__NUXT__={"layout":"default","data":[{}],"error":null,"serverRendered":true};</script><script src="/static/manifest.4f625a5f.js" defer></script><script src="/static/0-cf2867bf.js" defer></script><script src="/static/76-df579d0b.js" defer></script><script src="/static/common.d774ec7b.js" defer></script><script src="/static/app.ff62209b.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html data-n-head-ssr data-n-head="">
  <head>
    <meta data-n-head="true" charset="utf-8"/><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"/><meta data-n-head="true" name="keywords" content="翻译,ES6,数据绑定"/><meta data-n-head="true" name="description" content="手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定"/><title data-n-head="true">[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定 | 文蔺的博客</title><link data-n-head="true" rel="favicon" href="/favicon.ico"/><link rel="stylesheet" href="/static/common.5ad111a3.css"><style data-vue-ssr-id="645210e9:0">#__layout,#__nuxt,.wrapper{width:100%;height:100%}.main{height:100%}.main>article,.main>div,.main>section{min-height:100%;margin-bottom:-81px}.main>article:after,.main>div:after,.main>section:after{display:block;content:"";height:81px}.main>article,.main>div,.main>section{border-bottom:0}.main>#footer{position:relative;z-index:1;border-top:0}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><div class="nuxt-progress" style="width:0%;height:2px;background-color:black;opacity:0;"></div><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a><span>文蔺的博客</span></div><ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i><span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i><span> 归档</span></a></li><li><a href="/tags" title="标签"><i class="iconfont icon-tags"></i><span> 标签</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i><span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i><span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i><span> 收藏</span></a></li></ul></div><ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a><!----><!----><a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a><a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav><div id="header"><div class="btn-bar"><i></i></div><h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1><a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div><div id="sidebar-mask" style="display:none;"></div><div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-11-14</div></div><h1 class="title">[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定</h1><div class="entry-content"><blockquote><p style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
        原文作者: <a href="https://blog.risingstack.com/author/bertalan/" target="_blank">Bertalan Miklos</a><br>
        原文地址: <a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-es6-proxy/">https://blog.risingstack.com/writing-a-javascript-framework-data-binding-es6-proxy/</a><br>
        译文地址: <a href="http://www.wemlion.com/post/es6-proxy-data-binding">http://www.wemlion.com/post/es6-proxy-data-binding</a><br>
        本文由 <a href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。<br>
        著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote><p><strong>本文是“编写 JavaScript 框架”系列的第五章。在本章中，我将介绍如何使用 ES6 Proxy 实现简单、强大的数据绑定。</strong></p><p>本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目<a href="http://nx-framework.com" target="_blank">主页</a>查看。</p><p>本系列章节如下：</p><ul><li><a href="/2016/nx-project-structure/">项目结构（Project structuring）</a></li><li><a href="/2016/execution-timing/">执行调度（Execution timing）</a></li><li><a href="/2016/sandbox-code-evaluation/">沙箱求值（Sandboxed code evaluation）</a></li><li><a href="/2016/data-bind-dirty-checking">数据绑定简介</a></li><li>ES6 Proxy 实现数据绑定 (本文)</li><li>自定义元素 </li><li>客户端路由</li></ul><h2 id="-">知识回顾</h2><p>ES6 让 JavaScript 变得更加优雅，但多数新特性不过是语法糖罢了。Proxy 是少数几个无法 polyfill 的新增特性。如果还不太熟悉 Proxy，请先看一眼 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank">MDN 上的 Proxy 文档</a>。</p><p>如果对 ES6 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank">Reflection API</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank">Set</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank">Map</a> 以及 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank">WeakMap</a> 有所了解，那便是极好的。</p><h2 id="nx-observe">nx-observe</h2><p><a href="https://github.com/RisingStack/nx-observe" target="_blank">nx-observe</a> 是一个不到 140 行代码的数据绑定方案。对外暴露的 <textarea width="0" height="0" class="codespan" style="display:none;">observable(obj)</textarea> 、<textarea width="0" height="0" class="codespan" style="display:none;">observe(fn)</textarea>二者分别用于创建 observable 和 observer 函数。当使用到的 observable 对象发生属性变化时，observer 函数将自动执行。示例如下：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%20observable%20object%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20person%20%3D%20observable(%7B%3Cspan%20class%3D%22hljs-attr%22%3Ename%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'John'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-attr%22%3Eage%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-number%22%3E20%3C%2Fspan%3E%7D)%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eprint%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3E%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E%60%3Cspan%20class%3D%22hljs-subst%22%3E%24%7Bperson.name%7D%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-subst%22%3E%24%7Bperson.age%7D%3C%2Fspan%3E%60%3C%2Fspan%3E)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20observer%20%E5%87%BD%E6%95%B0%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'John%2C%2020'%3C%2Fspan%3E%0Aobserve(print)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'Dave%2C%2020'%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20person.name%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'Dave'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-number%22%3E100%3C%2Fspan%3E)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'Dave%2C%2022'%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20person.age%20%3D%20%3Cspan%20class%3D%22hljs-number%22%3E22%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-number%22%3E200%3C%2Fspan%3E)&lt;/code&gt;</textarea><p>每当 <textarea width="0" height="0" class="codespan" style="display:none;">person.name</textarea> 或 <textarea width="0" height="0" class="codespan" style="display:none;">person.age</textarea> 发生变化，传给 <textarea width="0" height="0" class="codespan" style="display:none;">observe()</textarea> 的 <textarea width="0" height="0" class="codespan" style="display:none;">print</textarea> 函数就会重新运行。在这里，<textarea width="0" height="0" class="codespan" style="display:none;">print</textarea> 被称为 observer 函数。</p><p>如果对更多例子感兴趣，可以点开 <a href="https://github.com/RisingStack/nx-observe#example" target="_blank">GitHub readme</a> 或 <a href="http://nx-framework.com/docs/spa/observer" target="_blank">NX 主页</a>，看看更逼真的场景。</p><h2 id="-observable">实现简单的 observable</h2><p>接下来的小节解释 nx-observe 底层发生了什么。首先介绍 observable 对象的属性变化是如何被侦测到的，又是如何匹配 observer 的。然后再展示怎样运行这些由变化触发的 observer 函数。</p><h3 id="-">注册变化</h3><p>变化是通过由 ES6 Proxy 包装后的 observable 对象注册的。在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank">Reflection API</a> 的协助下，这些 proxy 能够完美拦截 get 和 set 操作。</p><p>下面代码中使用的 <textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea> 和 <textarea width="0" height="0" class="codespan" style="display:none;">queueObserver()</textarea> 会在下一节中解释。目前只需要知道，<textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea> 总是指向当前执行的 observer 函数，<textarea width="0" height="0" class="codespan" style="display:none;">queueObserver()</textarea> 把即将执行的 observer 加入队列。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E5%B0%86%20observable%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84%E5%88%B0%0A%20%20%20%E9%82%A3%E4%BA%9B%E4%BD%BF%E7%94%A8%E4%BA%86%E8%BF%99%E4%BA%9B%E5%B1%9E%E6%80%A7%E7%9A%84%20observer%20%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88%E4%B8%AD%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20observers%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EWeakMap%3C%2Fspan%3E()%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E6%8C%87%E5%90%91%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%20observer%20%E5%87%BD%E6%95%B0%EF%BC%8C%0A%20%20%20%E4%B9%9F%E5%8F%AF%E8%83%BD%E6%98%AF%20undefined%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20currentObserver%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E6%88%90%20proxy%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%B0%86%E5%85%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%20observable%20%E5%AF%B9%E8%B1%A1%EF%BC%8C%0A%20%20%20%E8%BF%98%E4%B8%BA%20observers%20%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%A9%BA%20Map%EF%BC%8C%0A%20%20%20%E7%94%A8%E4%BA%8E%E4%BF%9D%E5%AD%98%20property-observer%20%E7%BB%84%E5%90%88%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobservable%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eobj%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20observers.set(obj%2C%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EMap%3C%2Fspan%3E())%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EProxy%3C%2Fspan%3E(obj%2C%20%7Bget%2C%20set%7D)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E6%8B%A6%E6%88%AA%20get%20%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%8B%A5%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E6%AD%A3%E5%9C%A8%0A%20%20%20%E6%89%A7%E8%A1%8C%E7%9A%84%20observer%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BC%9A%E5%81%9A%E4%BB%BB%E4%BD%95%E4%BA%8B%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eget%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%2C%20receiver%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20result%20%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3EReflect%3C%2Fspan%3E.get(target%2C%20key%2C%20receiver)%0A%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(currentObserver)%20%7B%0A%20%20%20%20%20registerObserver(target%2C%20key%2C%20currentObserver)%0A%20%20%20%7D%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20result%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E8%8B%A5%E5%BD%93%E5%89%8D%E6%9C%89%20observer%20%E5%87%BD%E6%95%B0%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%EF%BC%8C%0A%20%20%20%E6%9C%AC%E5%87%BD%E6%95%B0%E4%BC%9A%E5%B0%86%E8%AF%A5%20observer%20%E5%87%BD%E6%95%B0%E4%B8%8E%0A%20%20%20%E5%BD%93%E5%89%8D%E5%8F%96%E5%88%B0%E7%9A%84%20observable%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E9%85%8D%E5%AF%B9%EF%BC%8C%0A%20%20%20%E5%B9%B6%E5%B0%86%E5%AE%83%E4%BB%AC%E4%BF%9D%E5%AD%98%E5%88%B0%20observers%20Map%20%E4%B8%AD%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EregisterObserver%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%2C%20observer%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20observersForKey%20%3D%20observers.get(target).get(key)%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(!observersForKey)%20%7B%0A%20%20%20%20observersForKey%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3ESet%3C%2Fspan%3E()%0A%20%20%20%20observers.get(target).set(key%2C%20observersForKey)%0A%20%20%7D%0A%20%20observersForKey.add(observer)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E6%8B%A6%E6%88%AA%20set%20%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%0A%20%20%20%E6%89%80%E6%9C%89%20observer%20%E5%8A%A0%E5%85%A5%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eset%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%2C%20value%2C%20receiver%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20observersForKey%20%3D%20observers.get(target).get(key)%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(observersForKey)%20%7B%0A%20%20%20%20observersForKey.forEach(queueObserver)%0A%20%20%7D%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EReflect%3C%2Fspan%3E.set(target%2C%20key%2C%20value%2C%20receiver)%0A%7D&lt;/code&gt;</textarea><p>尚未设置 <textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea> 时，<textarea width="0" height="0" class="codespan" style="display:none;">get</textarea> 不会做任何事情。否则，<textarea width="0" height="0" class="codespan" style="display:none;">get</textarea> 操作会将拿到的 observable 对象属性与当前运行的 observer 函数组合（pair）在一起，保存到 <textarea width="0" height="0" class="codespan" style="display:none;">observers</textarea> WeakMap 中。对于 observable 对象的每个属性，observer 函数都保存在一个 <textarea width="0" height="0" class="codespan" style="display:none;">Set</textarea> 中。这样可以保证不会出现重复。</p><p><textarea width="0" height="0" class="codespan" style="display:none;">set</textarea> 会检索所有与 observable 对象变动的属性相关的 observer，并将它们加入稍后执行的队列。</p><p>下图展示了前面的例子的执行步骤。</p><p><img alt="JavaScript data binding with es6 proxy - observable code sample"></p><ol><li>创建 observable 对象 <textarea width="0" height="0" class="codespan" style="display:none;">person</textarea>；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea> 被设为 <textarea width="0" height="0" class="codespan" style="display:none;">print</textarea>；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">print</textarea> 开始执行；</li><li>在 <textarea width="0" height="0" class="codespan" style="display:none;">print</textarea> 内部检索到 <textarea width="0" height="0" class="codespan" style="display:none;">person.name</textarea>；</li><li>在 <textarea width="0" height="0" class="codespan" style="display:none;">person</textarea> 上触发 <textarea width="0" height="0" class="codespan" style="display:none;">get</textarea>；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">observers.get(person).get('name')</textarea> 检索到 <textarea width="0" height="0" class="codespan" style="display:none;">(person, name)</textarea> 组合的 observer Set；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea> (print) 被添加到 observer Set 中；</li><li>对 <textarea width="0" height="0" class="codespan" style="display:none;">person.age</textarea>，同理，执行前面 4-7 步；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">${person.name}, ${person.age}</textarea> 打印出来；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">print</textarea> 函数执行结束；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea> 变为 undefined；</li><li>其他代码开始运行；</li><li>设置 <textarea width="0" height="0" class="codespan" style="display:none;">person.age</textarea> 为新的值（22）；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">person</textarea> 上触发 <textarea width="0" height="0" class="codespan" style="display:none;">set</textarea>；</li><li><textarea width="0" height="0" class="codespan" style="display:none;">observers.get(person).get('age')</textarea> 检索到 <textarea width="0" height="0" class="codespan" style="display:none;">(person, age)</textarea> 组合的 observer Set，</li><li>observer Set 中的 observer（包括 <textarea width="0" height="0" class="codespan" style="display:none;">print</textarea>）入队准备执行；</li><li>再次执行 <textarea width="0" height="0" class="codespan" style="display:none;">print</textarea>。</li></ol><h3 id="observer-">observer 执行</h3><p>队列中的 observer 是分批异步执行的，因此性能很好。注册期间，这些 observer 被异步地添加到 <textarea width="0" height="0" class="codespan" style="display:none;">queuedObservers</textarea><textarea width="0" height="0" class="codespan" style="display:none;">Set</textarea> 中。<textarea width="0" height="0" class="codespan" style="display:none;">Set</textarea> 中不会包含重复元素，所以多次加入同一个 observer 也不会导致重复执行。如果该 <textarea width="0" height="0" class="codespan" style="display:none;">Set</textarea> 之前是空的，则会加入新的任务，在一段时间后迭代执行队列中所有的 observer。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E5%8C%85%E5%90%AB%E8%A7%A6%E5%8F%91%E7%9A%84%E5%B0%86%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%20observer%20%E5%87%BD%E6%95%B0%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20queuedObservers%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3ESet%3C%2Fspan%3E()%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E6%8C%87%E5%90%91%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%20observer%20%E5%87%BD%E6%95%B0%EF%BC%8C%0A%20%20%20%E4%B9%9F%E5%8F%AF%E8%83%BD%E6%98%AF%20undefined%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20currentObserver%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E6%9A%B4%E9%9C%B2%E7%9A%84%20observe%20%E5%87%BD%E6%95%B0%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobserve%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Efn%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20queueObserver(fn)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E5%B0%86%20observer%20%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%0A%20%20%20%E5%B9%B6%E7%A1%AE%E4%BF%9D%E9%98%9F%E5%88%97%E4%BC%9A%E5%B0%BD%E5%BF%AB%E6%89%A7%E8%A1%8C%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EqueueObserver%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eobserver%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(queuedObservers.size%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-number%22%3E0%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3EPromise%3C%2Fspan%3E.resolve().then(runObservers)%0A%20%20%7D%0A%20%20queuedObservers.add(observer)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%20observer%EF%BC%8C%0A%20%20%20%E5%AE%8C%E6%88%90%E5%90%8E%20currentObserver%20%E7%BD%AE%E4%B8%BA%20undefined%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3ErunObservers%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3E%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Etry%3C%2Fspan%3E%20%7B%0A%20%20%20%20queuedObservers.forEach(runObserver)%0A%20%20%7D%20%3Cspan%20class%3D%22hljs-keyword%22%3Efinally%3C%2Fspan%3E%20%7B%0A%20%20%20%20currentObserver%20%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%20%20%20%20queuedObservers.clear()%0A%20%20%7D%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20%E5%B0%86%E5%85%A8%E5%B1%80%E7%9A%84%20currentObserver%20%E5%8F%98%E9%87%8F%0A%20%20%E6%8C%87%E5%90%91%20observer%20%E5%B9%B6%E6%89%A7%E8%A1%8C%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3ErunObserver%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eobserver%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20currentObserver%20%3D%20observer%0A%20%20observer()%0A%7D&lt;/code&gt;</textarea><p>执行某一个 observer 时，上面的代码确保全局变量 <textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea> 指向该 observer。设置  <textarea width="0" height="0" class="codespan" style="display:none;">currentObserver</textarea>，会启用 <textarea width="0" height="0" class="codespan" style="display:none;">get</textarea>，监听、匹配执行时用到的 observable 对象的所有属性。</p><h2 id="-observable-tree">建立动态 observable tree</h2><p>到目前为止，模型结合单层数据结构使用起来还挺好，但还需要用 observable 手动包装那些值是对象的属性。比如，下面的代码就没法达到预期：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20person%20%3D%20observable(%7B%3Cspan%20class%3D%22hljs-attr%22%3Edata%3C%2Fspan%3E%3A%20%7B%3Cspan%20class%3D%22hljs-attr%22%3Ename%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'John'%3C%2Fspan%3E%7D%7D)%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eprint%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3E%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(person.data.name)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'John'%3C%2Fspan%3E%0Aobserve(print)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20does%20nothing%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20person.data.name%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'Dave'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-number%22%3E100%3C%2Fspan%3E)&lt;/code&gt;</textarea><p>为了让代码正常工作，还需要将 <textarea width="0" height="0" class="codespan" style="display:none;">observable({data: {name: 'John'}})</textarea> 替换成 <textarea width="0" height="0" class="codespan" style="display:none;">observable({data: observable({name: 'John'})})</textarea>。幸运的是，稍微修改一下 <textarea width="0" height="0" class="codespan" style="display:none;">get</textarea> 就能解决问题。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eget%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%2C%20receiver%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20result%20%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3EReflect%3C%2Fspan%3E.get(target%2C%20key%2C%20receiver)%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(currentObserver)%20%7B%0A%20%20%20%20registerObserver(target%2C%20key%2C%20currentObserver)%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Etypeof%3C%2Fspan%3E%20result%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'object'%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20observableResult%20%3D%20observable(result)%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3EReflect%3C%2Fspan%3E.set(target%2C%20key%2C%20observableResult%2C%20receiver)%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20observableResult%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20result%0A%7D&lt;/code&gt;</textarea><p>如果要返回的值是对象，那么在返回之前，<textarea width="0" height="0" class="codespan" style="display:none;">get</textarea> 会将其包装成 observable 对象。从性能方面来看也很完美，只会在需要的时候才会创建 observable 对象。</p><h2 id="-es5-">与 ES5 对比</h2><p>利用 ES5 的属性访问器（getter/setter）也能实现类似的数据绑定。很多流行的框架/库都在使用，如 <a href="https://mobxjs.github.io/mobx/" target="_blank">MobX</a> 和 <a href="https://vuejs.org/" target="_blank">Vue</a>。相较于访问器，使用 Proxy 有两大优势，也有一点不足之处。</p><h3 id="-">扩展属性</h3><p>在 JavaScript 中，扩展属性（Expando properties） 是指动态添加的属性。ES5 技术不支持扩展属性，每个属性的访问器都必须预先定义才能实现拦截操作。这也是为何当今预定义的键值集合成为趋势的原因。</p><p>而 Proxy 技术可以真正支持扩展属性，因为 Proxy 是按照单个对象定义的，对象的所有属性操作都可以拦截。</p><p>扩展属性很重要，典型例子就是数组。离开添加、删除功能，JavaScript 数组几乎毫无用处。针对此问题，ES5 数据绑定技术通常自定义数组方法，或者干脆重写。</p><h3 id="getter-setter">getter 和 setter</h3><p>通过某些特殊的语法，一些使用 ES5 方法的框架/库提供 <textarea width="0" height="0" class="codespan" style="display:none;">computed</textarea> 绑定属性。这些属性都有相应的原生实现，即 getter 和 setter。因为内部使用 getter 和 setter 实现数据绑定逻辑，那么也就无法再利用属性访问器了。</p><p>而 Proxy 可以拦截包括 getter 和 setter 在内的所有类型的属性访问和变动，所以这对 ES6 方法来说不构成问题。</p><h3 id="-">不足之处</h3><p>使用 Proxy 最大的不足还是在于浏览器支持。只有<a href="http://caniuse.com/#feat=proxy" target="_blank">比较新的浏览器</a>才支持，而 Proxy API 最精华的部分却无法通过 polyfill 实现。</p><h2 id="-">一点笔记</h2><p>上面介绍的数据绑定方法能够工作，但为了更容易理解，我进行了一些简化处理。下面会提到一些之前没有提到的问题。</p><h3 id="-">垃圾清理</h3><p>内存泄漏比较恶心。前面的代码在某种意义上来说有所避免，因为使用了 <textarea width="0" height="0" class="codespan" style="display:none;">WeakMap</textarea> 保存 observer。因此，observable  对象及与其关联的 observer 也会同时被回收。</p><p>不过，实际使用场景常常是中心化、持久化的存储，伴随着频繁的 DOM 变动。这种情况下，DOM 在垃圾回收之前，必须释放所有为其注册的 observer。前面的例子并没有实现该功能，但可以在 <a href="https://github.com/RisingStack/nx-observe/blob/master/observer.js" target="_blank">nx-observe 的代码</a> 中可以看到 <textarea width="0" height="0" class="codespan" style="display:none;">unobserve()</textarea> 方法如何实现。</p><h3 id="-">多次包装</h3><p>Proxy 是透明的，没有分辨 Proxy 和普通对象的原生方法。此外，它们还能无限嵌套，若不进行必要的预防，最终可能导致不停地对 observable 对象进行包装。</p><p>分辨 Proxy 与普通对象的办法有很多，例子中没有提到。其中一种办法是设置一个名为 <textarea width="0" height="0" class="codespan" style="display:none;">proxies</textarea> 的 <textarea width="0" height="0" class="codespan" style="display:none;">WeakSet</textarea> 对象，之后检查该 WeakSet 中是否存在某个 Proxy 对象即可。如果对 nx-observe 中的 <textarea width="0" height="0" class="codespan" style="display:none;">isObservable()</textarea> 方法感兴趣，可以去看<a href="https://github.com/RisingStack/nx-observe/blob/master/observer.js" target="_blank">代码</a>。</p><h3 id="-">继承</h3><p>nx-observe 还能与原型继承搭配工作。请看示例：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20parent%20%3D%20observable(%7B%3Cspan%20class%3D%22hljs-attr%22%3Egreeting%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'Hello'%3C%2Fspan%3E%7D)%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20child%20%3D%20observable(%7B%3Cspan%20class%3D%22hljs-attr%22%3Esubject%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'World!'%3C%2Fspan%3E%7D)%0A%3Cspan%20class%3D%22hljs-built_in%22%3EObject%3C%2Fspan%3E.setPrototypeOf(child%2C%20parent)%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eprint%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3E%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E%60%3Cspan%20class%3D%22hljs-subst%22%3E%24%7Bchild.greeting%7D%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-subst%22%3E%24%7Bchild.subject%7D%3C%2Fspan%3E%60%3C%2Fspan%3E)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'Hello%20World!'%3C%2Fspan%3E%0Aobserve(print)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'Hello%20There!'%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20child.subject%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'There!'%3C%2Fspan%3E)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'Hey%20There!'%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20parent.greeting%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'Hey'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-number%22%3E100%3C%2Fspan%3E)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%87%BA%20'Look%20There!'%3C%2Fspan%3E%0AsetTimeout(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20child.greeting%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'Look'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-number%22%3E200%3C%2Fspan%3E)&lt;/code&gt;</textarea><p>沿着原型链中的每个对象都会触发 <textarea width="0" height="0" class="codespan" style="display:none;">get</textarea> 操作，直到找到属性，因此在所有可能需要的地方都会注册 observer。</p><p>还有一个鲜为人知事情，<textarea width="0" height="0" class="codespan" style="display:none;">set</textarea> 操作同样会（偷偷摸摸地）沿着原型链进行。有些极端情况就是因此造成的，这里略过不谈。</p><h3 id="-">内部属性</h3><p>Proxy 还能拦截“内部属性访问”。你的代码中可能会使用许多通常基本都不考虑的内部属性。这样一些属性，通常会使用如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank">Symbol</a> 这样的值作为 key。这些属性也通常也能被 Proxy 拦截到，不过也也会有一些出现 bug 的情况。</p><h3 id="-">异步特性</h3><p>拦截到 <textarea width="0" height="0" class="codespan" style="display:none;">set</textarea>  操作时，observer 可以同步运行。这样有一些优势，比如减低复杂度，时序也可预测，堆栈跟踪更优雅。但某些场景下也会造成混乱。</p><p>想象一下，在单个循环中向6一个 observable 数组中添加 1000 项。数组长度会变化一千次，关联的 observer 也会在接连执行一千次。这恐怕不是什么好事。</p><p>另一个场景是双向观测。如若 observer 同步执行，下面的代码会造成无限循环。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20observable1%20%3D%20observable(%7B%3Cspan%20class%3D%22hljs-attr%22%3Eprop%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'value1'%3C%2Fspan%3E%7D)%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20observable2%20%3D%20observable(%7B%3Cspan%20class%3D%22hljs-attr%22%3Eprop%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'value2'%3C%2Fspan%3E%7D)%0A%0Aobserve(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20observable1.prop%20%3D%20observable2.prop)%0Aobserve(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20observable2.prop%20%3D%20observable1.prop)&lt;/code&gt;</textarea><p>鉴于这些，nx-observe 将 observer 添加到不允许重复的队列中一起执行，以避免<a href="https://en.wikipedia.org/wiki/Flash_of_unstyled_content" target="_blank">无样式内容闪动</a>。如果你对 microtask 的概念还不熟悉，请查看我之前关于浏览器时间控制的<a href="https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/" target="_blank">文章</a>。</p><h2 id="-">写在最后</h2><p>如果对 NX 框架感兴趣，请访问 <a href="http://nx-framework.com" target="_blank">主页</a>。胆大的读者还可以在Github 上查看 <a href="https://github.com/RisingStack/nx-framework" target="_blank">NX 源码</a> 和 <a href="https://github.com/RisingStack/nx-observe" target="_blank">nx-observe 源码</a>。 </p><p>希望你喜欢这篇文章，下一章我们将讨论自定义 HTML 元素。</p><h2 id="-">译者补记</h2><p>关于 Proxy，可以参阅：</p><ul><li><p><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank">ECMAScript 6 入门</a></p></li><li><p><a href="http://exploringjs.com/es6/ch_proxies.html" target="_blank">Metaprogramming with proxies</a></p></li><li><p><a href="http://www.2ality.com/2016/11/proxying-builtins.html" target="_blank">Pitfall: not all objects can be proxied transparently</a></p></li><li><p><a href="http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" target="_blank">实例解析 ES6 Proxy 使用场景</a></p></li><li><p><a href="http://www.cnblogs.com/ziyunfei/p/3187867.html" target="_blank">ES6中的代理对象</a></p></li></ul></div></article><nav class="pagination"><a href="/post/data-bind-dirty-checking" title="[译] 手把手教你写一个 Javascript 框架：数据绑定" class="prev">« [译] 手把手教你写一个 Javascript 框架：数据绑定</a><a href="/post/ie-filter" title="笔记：IE 下透明度问题" class="next">笔记：IE 下透明度问题 »</a></nav><div></div></div><footer id="footer" class="inner">
      © 2018 -  文蔺的博客
      <span> - </span><a href="/" class="nuxt-link-active">www.wemlion.com</a><br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> &amp; <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script type="text/javascript">window.__NUXT__={"layout":"default","data":[{}],"error":null,"serverRendered":true};</script><script src="/static/manifest.4f625a5f.js" defer></script><script src="/static/0-cf2867bf.js" defer></script><script src="/static/70-370e3f0c.js" defer></script><script src="/static/common.d774ec7b.js" defer></script><script src="/static/app.ff62209b.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html data-n-head-ssr data-n-head="">
  <head>
    <meta data-n-head="true" charset="utf-8"/><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"/><meta data-n-head="true" name="keywords" content="翻译,JavaScript,ES6"/><meta data-n-head="true" name="description" content="关于沙箱求值，ES6，Proxy，Symbol，WeakMap"/><title data-n-head="true">[译] 手把手教你写一个 Javascript 框架：沙箱求值 | 文蔺的博客</title><link data-n-head="true" rel="favicon" href="/favicon.ico"/><link rel="stylesheet" href="/static/common.5ad111a3.css"><style data-vue-ssr-id="645210e9:0">#__layout,#__nuxt,.wrapper{width:100%;height:100%}.main{height:100%}.main>article,.main>div,.main>section{min-height:100%;margin-bottom:-81px}.main>article:after,.main>div:after,.main>section:after{display:block;content:"";height:81px}.main>article,.main>div,.main>section{border-bottom:0}.main>#footer{position:relative;z-index:1;border-top:0}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><div class="nuxt-progress" style="width:0%;height:2px;background-color:black;opacity:0;"></div><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a><span>文蔺的博客</span></div><ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i><span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i><span> 归档</span></a></li><li><a href="/tags" title="标签"><i class="iconfont icon-tags"></i><span> 标签</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i><span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i><span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i><span> 收藏</span></a></li></ul></div><ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a><!----><!----><a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a><a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav><div id="header"><div class="btn-bar"><i></i></div><h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1><a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div><div id="sidebar-mask" style="display:none;"></div><div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-11-18</div></div><h1 class="title">[译] 手把手教你写一个 Javascript 框架：沙箱求值</h1><div class="entry-content"><blockquote><p style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
        原文作者: <a href="https://blog.risingstack.com/author/bertalan/" target="_blank">Bertalan Miklos</a><br>
        原文地址: <a href="https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/">https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/</a><br>
        译文地址: <a href="http://www.wemlion.com/post/sandbox-code-evaluation">http://www.wemlion.com/post/sandbox-code-evaluation</a><br>
        本文由 <a href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。<br>
        著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote><p><strong>本文是“编写 JavaScript 框架”系列的第三章。在本章中，我将介绍浏览器中对代码求值的几种不同方式及其存在的问题，也会介绍一种依赖 JavaScript 新特性的方法。</strong></p><p>本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目<a href="http://nx-framework.com/" target="_blank">主页</a>查看。</p><p>本系列章节如下：</p><ul><li><a href="/2016/nx-project-structure/">项目结构（Project structuring）</a></li><li><a href="/2016/execution-timing/">执行调度(Execution timing)</a></li><li>沙箱求值（本章）</li><li><a href="/2016/data-bind-dirty-checking">数据绑定简介</a></li><li><a href="/2016/es6-proxy-data-binding/">ES6 Proxy 实现数据绑定</a></li><li>自定义元素</li><li>客户端路由</li></ul><h2 id="-eval">邪恶 eval</h2><blockquote><p><textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 函数用来对字符串形式的 JavaScript 代码进行求值。</p></blockquote><p>常见的代码求值方法是使用 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 函数。通过 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 执行的代码可以访问闭包和全局作用域，所以可能导致<a href="https://en.wikipedia.org/wiki/Code_injection" target="_blank">代码注入(code injection)</a>，正因此 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 成为 JavaScript 中最臭名昭著的特性之一。</p><p>抛开上述缺点不说，<textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 在某些情况下还是很有用的。多数现代前端框架都需要 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 的这种功能，但是往往又因前述问题畏手畏脚。因此出现许多字符串求值方案，在沙箱而非全局作用域中进行操作。沙箱可以阻止代码访问与安全相关的数据，它通常是一个简单对象，用于替换代码中的全局对象。</p><h2 id="-">常见做法</h2><p>替代 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 最常见的方式是彻底重新实现。重新实现的过程由解析（parsing）、解释（interpreting）两步组成。首先由解析器创建<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">抽象语法树</a>，然后由解释器遍历语法树，将其译为运行在沙箱中的代码。</p><p>这种方案使用广泛，但可谓是杀鸡拿了把牛刀。放弃修补 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea>，选择从零开始重写，带来的后果就是，许多 bug 蠢蠢欲动，准备伺机而出。而随着语言的升级更新，也不得不频繁修改源码。</p><h2 id="-">另一种思路</h2><p><a href="http://nx-framework.com" target="_blank">NX</a>  尽可能避免了重新实现代码，采用一个很小的库处理求值，该库使用了一些较可能少为人知的新特性。</p><p>这一节逐步介绍这些特性，并使用它们解释用于代码求值的 <a href="https://github.com/RisingStack/nx-compile" target="_blank">nx-compile</a> 库。这个库有一个名为 <textarea width="0" height="0" class="codespan" style="display:none;">compileCode()</textarea> 的函数，工作方式如下：</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20code%20%3D%20compileCode(%3Cspan%20class%3D%22hljs-string%22%3E'return%20num1%20%2B%20num2'%3C%2Fspan%3E)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%2017%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(code(%7B%3Cspan%20class%3D%22hljs-attr%22%3Enum1%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-number%22%3E10%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-attr%22%3Enum2%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-number%22%3E7%3C%2Fspan%3E%7D))%0A%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20globalNum%20%3D%20%3Cspan%20class%3D%22hljs-number%22%3E12%3C%2Fspan%3E%20%20%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20otherCode%20%3D%20compileCode(%3Cspan%20class%3D%22hljs-string%22%3E'return%20globalNum'%3C%2Fspan%3E)%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A2%AB%E7%A6%81%E6%AD%A2%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%20undefined%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(otherCode(%7B%3Cspan%20class%3D%22hljs-attr%22%3Enum1%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-number%22%3E2%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-attr%22%3Enum2%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-number%22%3E3%3C%2Fspan%3E%7D))&lt;/code&gt;</textarea><p>待到本文结束，我们会用不到 20 行的代码实现 <textarea width="0" height="0" class="codespan" style="display:none;">compileCode()</textarea> 函数。</p><h3 id="-new-function-"><textarea width="0" height="0" class="codespan" style="display:none;">new Function()</textarea></h3><blockquote><p>Function 构造函数用于创建新的 Function 对象。在 JavaScript 中，所有函数都是 Function 对象。</p></blockquote><p>Function 构造函数可以达到 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 同样的目的。<textarea width="0" height="0" class="codespan" style="display:none;">new Function(...args, 'funcBody')</textarea> 对传入的 <textarea width="0" height="0" class="codespan" style="display:none;">'funcBody'</textarea> 字符进行求值，并返回执行这段代码的函数。<textarea width="0" height="0" class="codespan" style="display:none;">new Function()</textarea> 与 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea> 的不同主要体现在以下两方面：</p><ul><li><p><textarea width="0" height="0" class="codespan" style="display:none;">new Function()</textarea> 方法只会对传入的代码求值一次。调用返回函数时，只会运行代码，而不会重新求值。</p></li><li><p><textarea width="0" height="0" class="codespan" style="display:none;">new Function()</textarea> 方法无法访问闭包中的本地变量；不过还是可以访问全局作用域。</p></li></ul><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EcompileCode%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esrc%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EFunction%3C%2Fspan%3E(src)%0A%7D&lt;/code&gt;</textarea><p>对我们来说，<textarea width="0" height="0" class="codespan" style="display:none;">new Function()</textarea> 要优于 <textarea width="0" height="0" class="codespan" style="display:none;">eval()</textarea>。它性能更好，也更安全。不过要使其完全可用，还需要阻止其访问全局作用域。</p><h3 id="-with-"><textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 关键词</h3><blockquote><p><textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 能够扩展声明的作用域链。</p></blockquote><p>JavaScript 中，<textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 关键词较少露面。<textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 可以帮我们半沙箱化地执行代码。<textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 语句块首先会试着从传递的沙箱对象检索变量，如果没有找到，则会到闭包和全局作用域中寻找。前面说过，<textarea width="0" height="0" class="codespan" style="display:none;">new Function()</textarea> 能够阻止访问闭包中的变量，故现在只需考虑全局作用域的问题。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EcompileCode%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esrc%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20src%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'with%20(sandbox)%20%7B'%3C%2Fspan%3E%20%2B%20src%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%7D'%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EFunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-string%22%3E'sandbox'%3C%2Fspan%3E%2C%20src)%0A%7D&lt;/code&gt;</textarea><p>在内部实现中，<textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 使用了 <textarea width="0" height="0" class="codespan" style="display:none;">in</textarea> 操作。对于语句块中的所有变量访问，都会使用 <textarea width="0" height="0" class="codespan" style="display:none;">variable in sandbox</textarea> 条件进行判断。若条件为真，则从沙箱对象中读取变量；否则会去全局变量中寻找变量。在 <textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 操作过程中，我们可以让 <textarea width="0" height="0" class="codespan" style="display:none;">variable in sandbox</textarea> 永远返回 true，这样就能阻止访问全局变量。</p><p><img alt="Sandboxed code evaluation: Simple &amp;#39;with&amp;#39; statement"></p><h3 id="es6-proxy">ES6 Proxy</h3><blockquote><p>Proxy 对象用于自定义 Object 的一些基本操作，如属性读取、赋值等行为。</p></blockquote><p>ES6 <textarea width="0" height="0" class="codespan" style="display:none;">Proxy</textarea> 封装对象，并定义一些 trap 函数，这些函数可以拦截该对象的基本操作行为。操作对象时，就会调用相应的 trap 函数。使用 <textarea width="0" height="0" class="codespan" style="display:none;">Proxy</textarea> 封装沙箱对象，定义一个 <textarea width="0" height="0" class="codespan" style="display:none;">has</textarea> 操作 trap，即可覆盖 <textarea width="0" height="0" class="codespan" style="display:none;">in</textarea> 操作符的默认行为。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EcompileCode%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esrc%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20src%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'with%20(sandbox)%20%7B'%3C%2Fspan%3E%20%2B%20src%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%7D'%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20code%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EFunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-string%22%3E'sandbox'%3C%2Fspan%3E%2C%20src)%0A%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esandbox%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20sandboxProxy%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EProxy%3C%2Fspan%3E(sandbox%2C%20%7Bhas%7D)%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20code(sandboxProxy)%0A%20%20%7D%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E7%94%A8%E4%BA%8E%E6%8B%A6%E6%88%AA%E5%AF%B9%20sandboxProxy%20%E7%9A%84%20'in'%20%E6%93%8D%E4%BD%9C%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Ehas%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-literal%22%3Etrue%3C%2Fspan%3E%0A%7D&lt;/code&gt;</textarea><p>上面的代码耍了 <textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 代码块一把。<textarea width="0" height="0" class="codespan" style="display:none;">variable in sandbox</textarea> 将永远为真，因为 <textarea width="0" height="0" class="codespan" style="display:none;">has</textarea> trap 函数总是返回 true。<textarea width="0" height="0" class="codespan" style="display:none;">width</textarea> 代码块中的代码永远无法访问全局对象。</p><p><img alt="Sandboxed code evaluation: &amp;#39;with&amp;#39; statement and proxies"></p><h3 id="-symbol-unscopables-"><textarea width="0" height="0" class="codespan" style="display:none;">Symbol.unscopables</textarea></h3><blockquote><p>Symbol 是一种唯一的、不可变的数据类型，可用作对象属性标识符。</p></blockquote><p><textarea width="0" height="0" class="codespan" style="display:none;">Symbol.unscopables</textarea> 是一个驰名 symbol（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank">Well-known symbol</a>）。所谓“驰名 symbol”，实际上是一些内置 JavaScript <textarea width="0" height="0" class="codespan" style="display:none;">Symbol</textarea>，代表某些内部语言行为。驰名 symbol 可以用于添加或重写一些行为，如数据的迭代、基本类型转换。</p><blockquote><p>Symbol.unscopables 用于指定对象的一些固有和继承属性，这些属性被排除在 <textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 所绑定的环境之外无法读取。</p></blockquote><p><textarea width="0" height="0" class="codespan" style="display:none;">Symbol.unscopables</textarea> 用于定义对象的 unscopable 属性（译者：不译，请自行领会）。<textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 声明中的沙箱对象的 unscopable 属性无法读取，这些属性会从闭包、全局作用域中读取。通常极少需要用到 <textarea width="0" height="0" class="codespan" style="display:none;">Symbol.unscopables</textarea>。在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables" target="_blank">这里</a>可以看到引入 <textarea width="0" height="0" class="codespan" style="display:none;">Symbol.unscopables</textarea> 的原因。</p><p><img alt="Sandboxed code evaluation: &amp;#39;with&amp;#39; statement and proxies. A security issue."></p><p>我们为沙箱对象 proxy 添加一个<textarea width="0" height="0" class="codespan" style="display:none;">get</textarea> trap 函数，拦截检索 <textarea width="0" height="0" class="codespan" style="display:none;">Symbol.unscopables</textarea> 属性的行为，总是返回 undefined。这样会骗到 <textarea width="0" height="0" class="codespan" style="display:none;">with</textarea> 代码块，使其认为沙箱对象没有任何 unscopable 属性。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EcompileCode%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esrc%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20src%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'with%20(sandbox)%20%7B'%3C%2Fspan%3E%20%2B%20src%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%7D'%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20code%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EFunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-string%22%3E'sandbox'%3C%2Fspan%3E%2C%20src)%0A%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esandbox%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20sandboxProxy%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EProxy%3C%2Fspan%3E(sandbox%2C%20%7Bhas%2C%20get%7D)%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20code(sandboxProxy)%0A%20%20%7D%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Ehas%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-literal%22%3Etrue%3C%2Fspan%3E%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eget%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(key%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3ESymbol%3C%2Fspan%3E.unscopables)%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20target%5Bkey%5D%0A%7D&lt;/code&gt;</textarea><p><img alt="Sandboxed code evaluation: &amp;#39;with&amp;#39; statement and proxies. Has and get traps."></p><h3 id="-weakmap-">使用 WeakMap 进行缓存</h3><p>代码现在是安全的，但性能还有可提升之处：可以看到，每次调用返回的函数时都会新建一个 <textarea width="0" height="0" class="codespan" style="display:none;">Proxy</textarea>。通过缓存可以避免该问题，每次调用时，若沙箱对象相同，则可以使用同一个 <textarea width="0" height="0" class="codespan" style="display:none;">Proxy</textarea> 对象。</p><p>Proxy 对象与沙箱对象一一对应，故可以单纯地将其作为沙箱对象的一个属性。不过，这可能会对外暴露代码实现细节。另外，若使用的是 <textarea width="0" height="0" class="codespan" style="display:none;">Object.freeze()</textarea> 冻结之后的不可变沙箱对象也不行。所以采用 <textarea width="0" height="0" class="codespan" style="display:none;">WeakMap</textarea> 才是更好的选择。</p><blockquote><p>WeakMap 对象是一个键值对集合。键为弱引用，必须是对象；值可以为任意类型。</p></blockquote><p><textarea width="0" height="0" class="codespan" style="display:none;">WeakMap</textarea> 可在不直接扩展对象属性的情况下为该对象附加数据。通过 <textarea width="0" height="0" class="codespan" style="display:none;">WeakMap</textarea> 间接为沙箱对象添加缓存的 <textarea width="0" height="0" class="codespan" style="display:none;">Proxy</textarea>。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20sandboxProxies%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EWeakMap%3C%2Fspan%3E()%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EcompileCode%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esrc%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20src%20%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'with%20(sandbox)%20%7B'%3C%2Fspan%3E%20%2B%20src%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%7D'%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20code%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EFunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-string%22%3E'sandbox'%3C%2Fspan%3E%2C%20src)%0A%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Esandbox%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(!sandboxProxies.has(sandbox))%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20sandboxProxy%20%3D%20%3Cspan%20class%3D%22hljs-keyword%22%3Enew%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EProxy%3C%2Fspan%3E(sandbox%2C%20%7Bhas%2C%20get%7D)%0A%20%20%20%20%20%20sandboxProxies.set(sandbox%2C%20sandboxProxy)%0A%20%20%20%20%7D%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20code(sandboxProxies.get(sandbox))%0A%20%20%7D%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Ehas%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-literal%22%3Etrue%3C%2Fspan%3E%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eget%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Etarget%2C%20key%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(key%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3ESymbol%3C%2Fspan%3E.unscopables)%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20target%5Bkey%5D%0A%7D&lt;/code&gt;</textarea><p>这样一来，只会为每个沙箱对象新建一次 <textarea width="0" height="0" class="codespan" style="display:none;">Proxy</textarea> 对象。</p><h3 id="-">最后一点</h3><p>上面的 <textarea width="0" height="0" class="codespan" style="display:none;">compileCode()</textarea> 例子仅 19 行代码，已经是一个可以工作的沙箱代码求值工具。如果有兴趣看看 nx-compile 的完整代码，可以访问 <a href="https://github.com/RisingStack/nx-compile" target="_blank">Github 仓库</a>。</p><p>除解释代码求值外，本章的主要目的是展示一些 ES6 新特性，用它们替代原有方式。贯穿整个例子，我试图展示了 <textarea width="0" height="0" class="codespan" style="display:none;">Proxy</textarea> 和 <textarea width="0" height="0" class="codespan" style="display:none;">Symbol</textarea> 的强大力量。</p><h2 id="-">写在最后</h2><p>如果对 NX 框架感兴趣，请访问 <a href="http://nx-framework.com/" target="_blank">主页</a>。胆大的读者还可以在 Github 上查看 <a href="https://github.com/RisingStack/nx-framework" target="_blank">NX 源码</a> 和 <a href="https://github.com/RisingStack/nx-observe" target="_blank">nx-observe 源码</a>。</p><p>希望你喜欢这篇文章。下一章我们将讨论 <a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/" target="_blank">数据绑定</a>。</p></div></article><nav class="pagination"><a href="/post/nx-project-structure" title="[译] 手把手教你写一个 Javascript 框架：项目结构" class="prev">« [译] 手把手教你写一个 Javascript 框架：项目结构</a><a href="/post/execution-timing" title="[译] 手把手教你写一个 Javascript 框架：执行调度" class="next">[译] 手把手教你写一个 Javascript 框架：执行调度 »</a></nav><div></div></div><footer id="footer" class="inner">
      © 2018 -  文蔺的博客
      <span> - </span><a href="/" class="nuxt-link-active">www.wemlion.com</a><br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> &amp; <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script type="text/javascript">window.__NUXT__={"layout":"default","data":[{}],"error":null,"serverRendered":true};</script><script src="/static/manifest.4f625a5f.js" defer></script><script src="/static/0-cf2867bf.js" defer></script><script src="/static/33-bbfe90d0.js" defer></script><script src="/static/common.d774ec7b.js" defer></script><script src="/static/app.ff62209b.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html data-n-head-ssr data-n-head="">
  <head>
    <meta data-n-head="true" charset="utf-8"/><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"/><meta data-n-head="true" name="keywords" content="翻译,Service Worker"/><meta data-n-head="true" name="description" content="Service Worker 生命周期"/><title data-n-head="true">[译] Service Worker 生命周期 | 文蔺的博客</title><link data-n-head="true" rel="favicon" href="/favicon.ico"/><link rel="stylesheet" href="/static/common.5ad111a3.css"><style data-vue-ssr-id="645210e9:0">#__layout,#__nuxt,.wrapper{width:100%;height:100%}.main{height:100%}.main>article,.main>div,.main>section{min-height:100%;margin-bottom:-81px}.main>article:after,.main>div:after,.main>section:after{display:block;content:"";height:81px}.main>article,.main>div,.main>section{border-bottom:0}.main>#footer{position:relative;z-index:1;border-top:0}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><div class="nuxt-progress" style="width:0%;height:2px;background-color:black;opacity:0;"></div><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a><span>文蔺的博客</span></div><ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i><span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i><span> 归档</span></a></li><li><a href="/tags" title="标签"><i class="iconfont icon-tags"></i><span> 标签</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i><span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i><span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i><span> 收藏</span></a></li></ul></div><ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a><!----><!----><a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a><a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav><div id="header"><div class="btn-bar"><i></i></div><h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1><a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div><div id="sidebar-mask" style="display:none;"></div><div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-07-25</div></div><h1 class="title">[译] Service Worker 生命周期</h1><div class="entry-content"><blockquote><p style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
        原文作者: <a href="https://twitter.com/ireaderinokun" target="_blank">@Ire Aderinokun</a><br>
        原文地址: <a href="https://bitsofco.de/the-service-worker-lifecycle/">https://bitsofco.de/the-service-worker-lifecycle/</a><br>
        译文地址: <a href="http://www.wemlion.com/post/the-service-worker-lifecycle">http://www.wemlion.com/post/the-service-worker-lifecycle</a><br>
        本文由 <a href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。<br>
        著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote><p>如果使用过 Service Worker，之前你可能遇到过这样的问题，原来的 Service Worker 还在起作用，即使文件本身已经更新过。其中的原因在于 Service Worker 生命周期中的一些微妙之处；它可能会被安装，而且是有效的，但实际上却没有被 document 纳入控制。</p><p>Service Worker 可能拥有以下六种状态的一种：<strong>解析成功（parsed）</strong>，<strong>正在安装（installing）</strong>，<strong>安装成功（installed）</strong>，<strong>正在激活（activating）</strong>，<strong>激活成功（activated）</strong>，<strong>废弃（redundant）</strong>。</p><p><img alt="Service Worker 状态"></p><h2 id="-parsed-">解析成功（Parsed）</h2><p>首次注册 Service Worker 时，浏览器解决脚本并获得入口点。如果解析成功（而且满足其他条件，如 HTTPS 协议），就可以访问到 Service Worker 注册对象（registration object），其中包含 Service Worker 的状态及其作用域。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20main.js%20*%2F%3C%2Fspan%3E%0A%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-string%22%3E'serviceWorker'%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-keyword%22%3Ein%3C%2Fspan%3E%20navigator)%20%7B%20%20%0A%20%20%20%20navigator.serviceWorker.register(%3Cspan%20class%3D%22hljs-string%22%3E'.%2Fsw.js'%3C%2Fspan%3E)%0A%20%20%20%20.then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eregistration%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E%22Service%20Worker%20Registered%22%3C%2Fspan%3E%2C%20registration)%3B%0A%20%20%20%20%7D)%0A%20%20%20%20.catch(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eerr%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-built_in%22%3Econsole%3C%2Fspan%3E.log(%3Cspan%20class%3D%22hljs-string%22%3E%22Service%20Worker%20Failed%20to%20Register%22%3C%2Fspan%3E%2C%20err)%3B%0A%20%20%20%20%7D)%0A%7D&lt;/code&gt;</textarea><p>Service Worker 注册成功，并不意味着它已经完成安装，也不能说明它已经激活，仅仅是脚本被成功解析，与 document 同源，而且源协议是 HTTPS。一旦完成注册，Service Worker 将进入下一状态。</p><h2 id="-installing-">正在安装（Installing）</h2><p>Service Worker 脚本解析完成后，浏览器会试着安装，进入下一状态，“installing”。在 Service Worker <textarea width="0" height="0" class="codespan" style="display:none;">注册（registration）</textarea> 对象中，我们可以通过 <textarea width="0" height="0" class="codespan" style="display:none;">installing</textarea> 子对象检查该状态。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20main.js%20*%2F%3C%2Fspan%3E%0Anavigator.serviceWorker.register(%3Cspan%20class%3D%22hljs-string%22%3E'.%2Fsw.js'%3C%2Fspan%3E).then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eregistration%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(registration.installing)%20%7B%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Service%20Worker%20is%20Installing%3C%2Fspan%3E%0A%20%20%20%20%7D%0A%7D)&lt;/code&gt;</textarea><p>在 installing 状态中，Service Worker 脚本中的 <textarea width="0" height="0" class="codespan" style="display:none;">install</textarea> 事件被执行。我们通常在安装事件中，为 document 缓存静态文件。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20sw.js%20*%2F%3C%2Fspan%3E%0Aself.addEventListener(%3Cspan%20class%3D%22hljs-string%22%3E'install'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eevent%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20event.waitUntil(%0A%20%20%20%20caches.open(currentCacheName).then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Ecache%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20cache.addAll(arrayOfFilesToCache)%3B%0A%20%20%20%20%7D)%0A%20%20)%3B%0A%7D)%3B&lt;/code&gt;</textarea><p>若事件中有 <textarea width="0" height="0" class="codespan" style="display:none;">event.waitUntil()</textarea> 方法，则 installing 事件会一直等到该方法中的 Promise 完成之后才会成功；若 Promise 被拒，则安装失败，Service Worker 直接进入<strong>废弃（redundant）</strong>状态。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20sw.js%20*%2F%3C%2Fspan%3E%0Aself.addEventListener(%3Cspan%20class%3D%22hljs-string%22%3E'install'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eevent%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20event.waitUntil(%0A%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EPromise%3C%2Fspan%3E.reject()%3B%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Failure%3C%2Fspan%3E%0A%20%20)%3B%0A%7D)%3B%20%0A%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Install%20Event%20will%20fail%3C%2Fspan%3E&lt;/code&gt;</textarea><h2 id="-installed-waiting-">安装成功/等待中（Installed/Waiting）</h2><p>如果安装成功，Service Worker 进入<strong>安装成功（installed）</strong>（也称为<strong>等待中[waiting]</strong>）状态。在此状态中，它是一个有效的但尚未激活的 worker。它尚未纳入 document 的控制，确切来说是在等待着从当前 worker 接手。</p><p>在 Service Worker <textarea width="0" height="0" class="codespan" style="display:none;">注册（registration）</textarea> 对象中，可通过 <textarea width="0" height="0" class="codespan" style="display:none;">waiting</textarea> 子对象检查该状态。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20main.js%20*%2F%3C%2Fspan%3E%0Anavigator.serviceWorker.register(%3Cspan%20class%3D%22hljs-string%22%3E'.%2Fsw.js'%3C%2Fspan%3E).then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eregistration%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(registration.waiting)%20%7B%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Service%20Worker%20is%20Waiting%3C%2Fspan%3E%0A%20%20%20%20%7D%0A%7D)&lt;/code&gt;</textarea><p>这是通知 App 用户升级新版本或自动升级的好时机。</p><h2 id="-activating-">正在激活（Activating）</h2><p>处于 waiting 状态的 Service Worker，在以下之一的情况下，会被触发 <strong>activating</strong> 状态。</p><ul><li><p>当前已无激活状态的 worker</p></li><li><p>Service Worker 脚本中的 <textarea width="0" height="0" class="codespan" style="display:none;">self.skipWaiting()</textarea> 方法被调用</p></li><li><p>用户已关闭 Service Worker 作用域下的所有页面，从而释放了此前处于激活态的 worker</p></li><li><p>超出指定时间，从而释放此前处于激活态的 worker</p></li></ul><p>处于 activating 状态期间，Service Worker 脚本中的 <textarea width="0" height="0" class="codespan" style="display:none;">activate</textarea> 事件被执行。我们通常在 activate 事件中，清理 cache 中的文件。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20sw.js%20*%2F%3C%2Fspan%3E%0Aself.addEventListener(%3Cspan%20class%3D%22hljs-string%22%3E'activate'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eevent%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20event.waitUntil(%0A%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%20cache%20%E5%90%8D%E7%A7%B0%3C%2Fspan%3E%0A%20%20%20%20caches.keys().then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3EcacheNames%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-built_in%22%3EPromise%3C%2Fspan%3E.all(%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E4%BA%8E%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC%E5%90%8D%E7%A7%B0%20cache%20%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20cacheNames.filter(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3EcacheName%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20cacheName%20!%3D%20currentCacheName%3B%0A%20%20%20%20%20%20%20%20%7D).map(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3EcacheName%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20%E5%88%A0%E9%99%A4%E5%86%85%E5%AE%B9%3C%2Fspan%3E%0A%20%20%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20caches.delete(cacheName)%3B%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20)%3B%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20end%20Promise.all()%3C%2Fspan%3E%0A%20%20%20%20%7D)%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20end%20caches.keys()%3C%2Fspan%3E%0A%20%20)%3B%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20end%20event.waitUntil()%3C%2Fspan%3E%0A%7D)%3B&lt;/code&gt;</textarea><p>与 install 事件类似，如果 activate 事件中存在 <textarea width="0" height="0" class="codespan" style="display:none;">event.waitUntil()</textarea> 方法，则在其中的 Promise 完成之后，激活才会成功。如果 Promise 被拒，激活事件失败，Service Worker 进入<strong>废弃（redundant）</strong>状态。</p><h2 id="-activated-">激活成功（Activated）</h2><p>如果激活成功，Service Worker 进入 <strong>active</strong> 状态。在此状态中，其成为接受 document 全面控制的激活态 worker。在 Service Worker <textarea width="0" height="0" class="codespan" style="display:none;">注册（registration）</textarea> 对象中，可以通过 <textarea width="0" height="0" class="codespan" style="display:none;">active</textarea> 子对象检查此状态。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20main.js%20*%2F%3C%2Fspan%3E%0Anavigator.serviceWorker.register(%3Cspan%20class%3D%22hljs-string%22%3E'.%2Fsw.js'%3C%2Fspan%3E).then(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eregistration%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(registration.active)%20%7B%0A%20%20%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Service%20Worker%20is%20Active%3C%2Fspan%3E%0A%20%20%20%20%7D%0A%7D)&lt;/code&gt;</textarea><p>如果 Service Worker 处于激活态，就可以应对事件性事件 —— <textarea width="0" height="0" class="codespan" style="display:none;">fetch</textarea> 和 <textarea width="0" height="0" class="codespan" style="display:none;">message</textarea>。</p><textarea width="0" height="0" class="pre-area" style="display:none;">&lt;code class=&quot;hljs lang-javascript&quot;&gt;%3Cspan%20class%3D%22hljs-comment%22%3E%2F*%20In%20sw.js%20*%2F%3C%2Fspan%3E%0A%0Aself.addEventListener(%3Cspan%20class%3D%22hljs-string%22%3E'fetch'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eevent%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Do%20stuff%20with%20fetch%20events%3C%2Fspan%3E%0A%7D)%3B%0A%0Aself.addEventListener(%3Cspan%20class%3D%22hljs-string%22%3E'message'%3C%2Fspan%3E%2C%20%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Eevent%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%20%20%0A%20%20%3Cspan%20class%3D%22hljs-comment%22%3E%2F%2F%20Do%20stuff%20with%20postMessages%20received%20from%20document%3C%2Fspan%3E%0A%7D)%3B&lt;/code&gt;</textarea><h2 id="-redundant-">废弃（Redundant）</h2><p>Service Worker 可能以下之一的原因而被<strong>废弃</strong>（redundant，原意为“多余的，累赘的”）——</p><ul><li><p>installing 事件失败</p></li><li><p>activating 事件失败</p></li><li><p>新的 Service Worker 替换其成为激活态 worker</p></li></ul><p>如果 Service Worker 因前两个原因失败，我们可以通过开发者工具看到信息（以及其他相关信息）——</p><p><img alt="Service Worker Redundant in DevTools"></p><p>如果已存在前一版本的激活态 Service Worker，它会继续保持对 document 的控制。</p></div></article><nav class="pagination"><a href="/post/browse-ebay-with-style-and-speed-ebay" title="[译] eBay：style &amp; speed" class="prev">« [译] eBay：style &amp; speed</a><a href="/post/understanding-es6-modules-via-their-history" title="[译] 从发展历史理解 ES6 Module" class="next">[译] 从发展历史理解 ES6 Module »</a></nav><div></div></div><footer id="footer" class="inner">
      © 2018 -  文蔺的博客
      <span> - </span><a href="/" class="nuxt-link-active">www.wemlion.com</a><br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> &amp; <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script type="text/javascript">window.__NUXT__={"layout":"default","data":[{}],"error":null,"serverRendered":true};</script><script src="/static/manifest.4f625a5f.js" defer></script><script src="/static/0-cf2867bf.js" defer></script><script src="/static/28-fbc616ce.js" defer></script><script src="/static/common.d774ec7b.js" defer></script><script src="/static/app.ff62209b.js" defer></script>
  </body>
</html>

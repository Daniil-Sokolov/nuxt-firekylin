webpackJsonp([76],{"+6GB":function(s,e,a){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var t=a("Up0K"),r=a("IBRr"),i=a("VU/8")(t.a,r.a,!1,null,null,null);i.options.__file="pages/post/data-bind-dirty-checking.vue",e.default=i.exports},IBRr:function(s,e,a){"use strict";var t=function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("div",{attrs:{id:"page-post"}},[a("article",{staticClass:"post detail"},[a("div",{staticClass:"meta"},[a("div",{staticClass:"date"},[s._v(s._s(s.post.create_time))])]),a("h1",{staticClass:"title"},[s._v(s._s(s.post.title))]),a("div",{staticClass:"entry-content"},[s.post.translation?a("blockquote",[a("p",{staticStyle:{"white-space":"nowrap",overflow:"hidden","text-overflow":"ellipsis"}},[s._v("\n        原文作者: "),a("a",{attrs:{href:s.post.translation.social,target:"_blank"}},[s._v(s._s(s.post.translation.author))]),a("br"),s._v("\n        原文地址: "),a("a",{attrs:{href:s.post.translation.from}},[s._v(s._s(s.post.translation.from))]),a("br"),s._v("\n        译文地址: "),a("a",{attrs:{href:s.post_url}},[s._v(s._s(s.post_url))]),a("br"),s._v("\n        本文由 "),a("a",{attrs:{href:this.$config.site_url}},[s._v(s._s(this.$config.site_owner))]),s._v(" 翻译，转载请保留此声明。"),a("br"),s._v("\n        著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。\n        ")])]):s._e(),s._m(0),s._m(1),a("p",[s._v("本系列章节如下：")]),s._m(2),a("h2",{attrs:{id:"-"}},[s._v("数据绑定简介")]),s._m(3),a("p",[s._v("上面这个基本定义指出了数据绑定技术的通用构建模块。")]),a("ul",[a("li",[s._v("定义数据提供者、消费者")]),a("li",[s._v("定义哪些变化触发数据同步")]),a("li",[s._v("数据提供者监听变化的方式")]),a("li",[s._v("发送变化时运行的同步函数 —— 下文会将该函数称作 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")])])]),a("p",[s._v("不同数据绑定技术采用不同方式实现以上几步。接下来几个小节介绍其中两种技术，即脏检查、getter/setter 访问器方法。介绍完它们后我将简要讨论它们各自的优缺点。")]),a("h3",{attrs:{id:"-"}},[s._v("脏检查")]),a("p",[s._v("脏检查可能是最广为人知的数据绑定方法。它是一种不错的传统选择，因其概念简单，无需复杂的语言特性支持。")]),a("h3",{attrs:{id:"-"}},[s._v("脏检查语法")]),a("p",[s._v("定义数据提供者和消费者无需任何特殊语法，仅靠普通 JavaScript 对象即可。")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v("<code class=\"hljs lang-javascript\">%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20provider%20%3D%20%7B%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Emessage%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'Hello%20World'%3C%2Fspan%3E%0A%7D%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20consumer%20%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3Edocument%3C%2Fspan%3E.createElement(%3Cspan%20class%3D%22hljs-string%22%3E'p'%3C%2Fspan%3E)</code>")]),a("p",[s._v("数据同步通常由提供者属性变化触发。那些需要对变化进行观察的属性，必须明确映射到各自的"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v("函数。")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v("<code class=\"hljs lang-javascript\">observe(provider%2C%20%3Cspan%20class%3D%22hljs-string%22%3E'message'%3C%2Fspan%3E%2C%20message%20%3D%26gt%3B%20%7B%0A%20%20consumer.innerHTML%20%3D%20message%0A%7D)</code>")]),a("p",[a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observe()")]),s._v(" 函数仅仅保存了 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("(provider, property) -> handler")]),s._v(" 映射，留作后用。")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v('<code class="hljs lang-javascript">%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobserve%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%2C%20prop%2C%20handler%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20provider._handlers%5Bprop%5D%20%3D%20handler%0A%7D</code>')]),a("p",[s._v("这样一来就可以定义数据提供者、消费者，为属性变化注册"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v("函数。公有 API 部分已经完成，下面要完成的是内部实现。")]),a("h3",{attrs:{id:"-"}},[s._v("监听变化")]),a("p",[s._v("脏检查之所以“脏”是有原因的。它依赖周期性检查，而非直接监听属性变化。这种周期性检查通常称作 digest cycle。在一个 digest cycle 内，遍历由"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observe()")]),s._v("所添加的每一个 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("(provider, property) -> handler")]),s._v(" 入口，并检查属性自上一次遍历以来是否发生了变化。若发生变化，则运行"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v("函数。简单实现如下：")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v('<code class="hljs lang-javascript">%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Edigest%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3E%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20providers.forEach(digestProvider)%0A%7D%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EdigestProvider%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Efor%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20prop%20%3Cspan%20class%3D%22hljs-keyword%22%3Ein%3C%2Fspan%3E%20provider._handlers)%20%7B%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(provider._prevValues%5Bprop%5D%20!%3D%3D%20provider%5Bprop%5D)%20%7B%0A%20%20%20%20%20%20provider._prevValues%5Bprop%5D%20%3D%20provider%5Bprop%5D%0A%20%20%20%20%20%20handler(provider%5Bprop%5D)%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D</code>')]),a("p",[a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("digest()")]),s._v(" 函数需要不时运行，以保障状态同步。")]),a("h2",{attrs:{id:"getter-setter-"}},[s._v("getter/setter 访问器方法")]),a("p",[s._v("getter/setter 访问器方法是当前的主流趋势，其支持广泛程度稍低，因为需要用到 ES5 getter/setter 功能。但这种方法之优雅足以弥补这个问题。")]),a("h3",{attrs:{id:"-"}},[s._v("访问器语法")]),a("p",[s._v("定义数据提供者需要一些特殊语法。普通提供者对象需要传给"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observable()")]),s._v("函数，转换为可观察对象。")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v("<code class=\"hljs lang-javascript\">%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20provider%20%3D%20observable(%7B%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Egreeting%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'Hello'%3C%2Fspan%3E%2C%0A%20%20%3Cspan%20class%3D%22hljs-attr%22%3Esubject%3C%2Fspan%3E%3A%20%3Cspan%20class%3D%22hljs-string%22%3E'World'%3C%2Fspan%3E%0A%7D)%0A%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20consumer%20%3D%20%3Cspan%20class%3D%22hljs-built_in%22%3Edocument%3C%2Fspan%3E.createElement(%3Cspan%20class%3D%22hljs-string%22%3E'p'%3C%2Fspan%3E)</code>")]),a("p",[s._v("这完全可以弥补简单的 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v(" 映射语法。在脏检查中，我们必须像下面这样，为每一个观察属性明确进行定义：")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v("<code class=\"hljs lang-javascript\">observe(provider%2C%20%3Cspan%20class%3D%22hljs-string%22%3E'greeting'%3C%2Fspan%3E%2C%20greeting%20%3D%26gt%3B%20%7B%0A%20%20consumer.innerHTML%20%3D%20greeting%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20'%3C%2Fspan%3E%20%2B%20provider.subject%0A%7D)%0A%0Aobserve(provider%2C%20%3Cspan%20class%3D%22hljs-string%22%3E'subject'%3C%2Fspan%3E%2C%20subject%20%3D%26gt%3B%20%7B%0A%20%20consumer.innerHTML%20%3D%20provider.greeting%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20'%3C%2Fspan%3E%20%2B%20subject%0A%7D)</code>")]),a("p",[s._v("又笨又长。访问器技术可以在 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v(" 函数中自动检测用到的提供者属性，这样就可以简化以上代码。")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v("<code class=\"hljs lang-javascript\">observe(%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-params%22%3E()%3C%2Fspan%3E%20%3D%26gt%3B%3C%2Fspan%3E%20%7B%0A%20%20consumer.innerHTML%20%3D%20provider.greeting%20%2B%20%3Cspan%20class%3D%22hljs-string%22%3E'%20'%3C%2Fspan%3E%20%2B%20provider.subject%0A%7D)</code>")]),a("p",[a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observe()")]),s._v(" 的实现与脏检查并不相同。我们仅仅需要执行传入的 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v("，并在其执行期间将其标记为当前活动函数。")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v('<code class="hljs lang-javascript">%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20activeHandler%0A%0A%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobserve%3C%2Fspan%3E(%3Cspan%20class%3D%22hljs-params%22%3Ehandler%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20activeHandler%20%3D%20handler%0A%20%20handler()%0A%20%20activeHandler%20%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%7D</code>')]),a("p",[s._v("我们利用 JavaScript 单线程特点，采用单一的"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("activehandler")]),s._v("变量来记录当前运行的"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v(" 函数。")]),a("h3",{attrs:{id:"-"}},[s._v("监听变化")]),a("p",[s._v("“访问器技术”终于闪亮登场。借助于 getter/setter 访问器在背后的强力支持，数据提供者 provider 的能力大大增强。基本的思想是，拦截 provider 的属性获取、设置操作。")]),a("ul",[a("li",[a("p",[s._v("get：如果存在正在运行的"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("activeHandler")]),s._v("，则保存"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("(provider, property) -> activeHandler")]),s._v("映射，稍后使用。")])]),a("li",[a("p",[s._v("set：运行所有 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("(provide, property)")]),s._v(" 对应的 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v("函数。")])])]),a("p",[a("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://s.ssl.qhres.com/static/363a87a8b3f27981.svg",expression:"`https://s.ssl.qhres.com/static/363a87a8b3f27981.svg`"}],attrs:{alt:"The accessor data binding technique."}})]),a("p",[s._v("下面是监听单个属性变化的简单实现：")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v('<code class="hljs lang-javascript">%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3EobservableProp%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%2C%20prop%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20value%20%3D%20provider%5Bprop%5D%0A%20%20%3Cspan%20class%3D%22hljs-built_in%22%3EObject%3C%2Fspan%3E.defineProperty(provider%2C%20prop%2C%20%7B%0A%20%20%20%20get%20()%20%7B%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(activeHandler)%20%7B%0A%20%20%20%20%20%20%20%20provider._handlers%5Bprop%5D%20%3D%20activeHandler%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Ereturn%3C%2Fspan%3E%20value%0A%20%20%20%20%7D%2C%0A%20%20%20%20set%20(newValue)%20%7B%0A%20%20%20%20%20%20value%20%3D%20newValue%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Econst%3C%2Fspan%3E%20handler%20%3D%20obj._handlers%5Bprop%5D%0A%20%20%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(handler)%20%7B%0A%20%20%20%20%20%20%20%20activeHandler%20%3D%20handler%0A%20%20%20%20%20%20%20%20handler()%0A%20%20%20%20%20%20%20%20activeHandler%20%3D%20%3Cspan%20class%3D%22hljs-literal%22%3Eundefined%3C%2Fspan%3E%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D)%0A%7D</code>')]),a("p",[s._v("上一节提到的"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observable()")]),s._v("函数会递归遍历 provider 的属性，并使用 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observableProp()")]),s._v(" 函数将它们统统转换为可观察对象。")]),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"pre-area",attrs:{width:"0",height:"0"}},[s._v("<code class=\"hljs lang-javascript\">%3Cspan%20class%3D%22hljs-function%22%3E%3Cspan%20class%3D%22hljs-keyword%22%3Efunction%3C%2Fspan%3E%20%3Cspan%20class%3D%22hljs-title%22%3Eobservable%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-params%22%3Eprovider%3C%2Fspan%3E)%20%3C%2Fspan%3E%7B%0A%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Efor%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Elet%3C%2Fspan%3E%20prop%20%3Cspan%20class%3D%22hljs-keyword%22%3Ein%3C%2Fspan%3E%20provider)%20%7B%0A%20%20%20%20observableProp(provider%2C%20prop)%0A%20%20%20%20%3Cspan%20class%3D%22hljs-keyword%22%3Eif%3C%2Fspan%3E%20(%3Cspan%20class%3D%22hljs-keyword%22%3Etypeof%3C%2Fspan%3E%20provider%5Bprop%5D%20%3D%3D%3D%20%3Cspan%20class%3D%22hljs-string%22%3E'object'%3C%2Fspan%3E)%20%7B%0A%20%20%20%20%20%20observable(provider%5Bprop%5D)%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D</code>")]),a("p",[s._v("这只是一个简单实现，但用来对比两种技术已足够。")]),a("h2",{attrs:{id:"-"}},[s._v("两种技术对比")]),a("p",[s._v("本节将简要指出脏检查和访问器两种技术各自的优缺点。")]),a("h3",{attrs:{id:"-"}},[s._v("语法形式")]),a("p",[s._v("脏检查无需定义提供者、消费者，但将 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("(provider, property)")]),s._v(" 和 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v(" 进行映射的方式笨拙又不灵活。")]),a("p",[s._v("访问器技术需要使用 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observable()")]),s._v(" 函数对提供者进行封装，不过自动进行 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v(" 映射弥补了不足。对于使用数据绑定的大型项目来说，访问器技术是必备特性。")]),a("h3",{attrs:{id:"-"}},[s._v("性能")]),a("p",[s._v("脏检查早就因其性能表现臭名昭著。每次 digest cycle 中，需要对每个 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("(provider, property) -> handler")]),s._v(" 入口进行数次检查。此外，即便应用处于闲置状态也必须保持运转，因为它并不值得属性何时发生变化。")]),a("p",[s._v("访问器方法更快一些，但在一些大型可观察对象面前，性能也可能发生退化。使用访问器替换提供者的所有属性，通常是过重了。一种解决办法是在必要时动态建立 getter/setter，而不是一次性提前完成。此外，还有一种简单方法是使用一个 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("noObserve()")]),s._v(" 函数包装不需要的属性，告诉 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observable()")]),s._v(" 不要理会这些。但这会引入额外的语法。")]),a("h3",{attrs:{id:"-"}},[s._v("灵活性")]),a("p",[s._v("脏检查天生就能和扩展属性（动态添加的）以及访问器属性一起工作。")]),a("p",[s._v("访问器技术在这方面有个弱点。初始化 getter/setter 时，扩展属性并不包含在内。比如对数组来说，这就会导致问题，但也能通过手动调用 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("observableProp()")]),s._v(" 来解决。访问器属性也无法支持，因为访问器属性无法再包装一次。一种常见的解决办法是使用 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("computed()")]),s._v(" 函数替代 getter。不过这会引入更多自定义语法。")]),a("h3",{attrs:{id:"-"}},[s._v("时间控制")]),a("p",[s._v("脏检查给我们的自由并不多，因为我们无从得知属性实际发生变化的时机。"),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v(" 函数只能通过不时运行 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("digest()")]),s._v(" 循环而异步执行。")]),a("p",[s._v("使用访问器技术，getter/setter 是同步触发的，因此就有了选择上的自由。我们可以决定是否立即执行 "),a("textarea",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"codespan",attrs:{width:"0",height:"0"}},[s._v("handler()")]),s._v("，或者分批异步执行。前者保证了可预见性，后者则可以通过去重提升性能。")]),a("h2",{attrs:{id:"-"}},[s._v("关于下一章")]),s._m(4),a("h2",{attrs:{id:"-"}},[s._v("写在最后")]),s._m(5),s._m(6)])]),s.post.prev.title||s.post.next.title?a("nav",{staticClass:"pagination"},[s.post.prev.title?a("nuxt-link",{staticClass:"prev",attrs:{to:"/post/"+s.post.prev.pathname,title:s.post.prev.title}},[s._v("« "+s._s(s.post.prev.title))]):s._e(),s.post.next.title?a("nuxt-link",{staticClass:"next",attrs:{to:"/post/"+s.post.next.pathname,title:s.post.next.title}},[s._v(s._s(s.post.next.title)+" »")]):s._e()],1):s._e(),a("gitalk",{attrs:{tags:s.tags}})],1)};t._withStripped=!0;var r={render:t,staticRenderFns:[function(){var s=this.$createElement,e=this._self._c||s;return e("p",[e("strong",[this._v("本文是“编写 JavaScript 框架”系列的第四章。本章我将解释脏检查和基于getter/setter 访问器的数据绑定技术，并指出它们各自的优缺点。")])])},function(){var s=this.$createElement,e=this._self._c||s;return e("p",[this._v("本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目"),e("a",{attrs:{href:"http://nx-framework.com/",target:"_blank"}},[this._v("主页")]),this._v("查看。")])},function(){var s=this.$createElement,e=this._self._c||s;return e("ul",[e("li",[e("a",{attrs:{href:"/2016/nx-project-structure/"}},[this._v("项目结构（Project structuring）")])]),e("li",[e("a",{attrs:{href:"/2016/execution-timing/"}},[this._v("执行调度（Execution timing）")])]),e("li",[e("a",{attrs:{href:"/2016/sandbox-code-evaluation/"}},[this._v("沙箱求值（Sandboxed code evaluation）")])]),e("li",[this._v("数据绑定简介(本文)")]),e("li",[e("a",{attrs:{href:"/2016/es6-proxy-data-binding/"}},[this._v("ES6 Proxy 实现数据绑定")])]),e("li",[this._v("自定义元素")]),e("li",[this._v("客户端路由")])])},function(){var s=this.$createElement,e=this._self._c||s;return e("blockquote",[e("p",[this._v("数据绑定是将数据源与数据提供者、消费者绑定并在它们之间保持同步的一种基本技术。")])])},function(){var s=this.$createElement,e=this._self._c||s;return e("p",[this._v("下一章我将介绍 "),e("a",{attrs:{href:"https://github.com/RisingStack/nx-observe",target:"_blank"}},[this._v("nx-observe")]),this._v(" 数据绑定工具，阐述如何用 ES6 Proxy 替代  ES5 getters/setters，以弥补访问器技术的多数不足之处。")])},function(){var s=this.$createElement,e=this._self._c||s;return e("p",[this._v("如果对 NX 框架感兴趣，请访问 "),e("a",{attrs:{href:"http://nx-framework.com/",target:"_blank"}},[this._v("主页")]),this._v("。胆大的读者还可以在Github 上查看 "),e("a",{attrs:{href:"https://github.com/RisingStack/nx-framework",target:"_blank"}},[this._v("NX 源码")]),this._v(" 和 "),e("a",{attrs:{href:"https://github.com/RisingStack/nx-observe",target:"_blank"}},[this._v("nx-observe 源码")]),this._v("。")])},function(){var s=this.$createElement,e=this._self._c||s;return e("p",[this._v("希望你喜欢这篇文章。下一章我们将讨论 "),e("a",{attrs:{href:"https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/",target:"_blank"}},[this._v("沙箱求值（Sandboxed code evaluation）")]),this._v("。")])}]};e.a=r},Up0K:function(s,e,a){"use strict";var t={title:"[译] 手把手教你写一个 Javascript 框架：数据绑定",description:"手把手教你写一个 Javascript 框架：数据绑定",keywords:"翻译,ES6,数据绑定",pathname:"data-bind-dirty-checking",translation:{author:"Bertalan Miklos",social:"https://blog.risingstack.com/author/bertalan/",from:"https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/"},create_time:"2016-11-14",prev:{title:"[译] 手把手教你写一个 Javascript 框架：执行调度",pathname:"execution-timing"},next:{title:"[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定",pathname:"es6-proxy-data-binding"}};e.a={head:function(){return{title:t.title,meta:[{name:"keywords",content:t.keywords||""},{name:"description",content:t.description}]}},data:function(){return{post:t,post_url:this.$config.site_url+"/post/"+t.pathname,tags:t.tags}},mounted:function(){this.$fixCode()}}}});